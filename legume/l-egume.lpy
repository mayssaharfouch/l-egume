import sys
import os

try:
    import legume
    path_ = os.path.dirname(os.path.abspath('C:\\Users\\HP\\Documents\\l-egume\\legume\\l-egume.lpy'))#local absolute path of L-egume
    #path_ = r'C:\devel\l-egume\legume'#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\luzerne' #r'C:\devel\grassland'#
except:
    path_ = r'C:\\Users\\HP\\Documents\\l-egume\\legume'#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\luzerne' #r'C:\devel\grassland'#
path_leg = os.path.join(path_, 'input')#r'C:\devel\l-egume\l-egume\input'#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\L-gume' #r'C:\devel\grassland'
path_out = os.path.join(path_, 'output')#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\L-gume' #r'C:\devel\grassland'

sys.path.insert(0, path_)
sys.path.insert(0, path_leg)


from numpy.random import binomial, seed
from scipy import * 
from copy import deepcopy
import string
import time
from openalea.plantgl.all import *
import Obj3Dutils as o3d

try:
    from .soil3ds import soil_moduleN as solN #import de la version develop si module soil3ds est installe
    i#mport soil_moduleN3 as solN
except:
    import soil_moduleN3 as solN #soil_moduleN2_bis as solN #! renommer car dans nouvelle version Lpy, mot module est reserve et fait planter!

try:
    from .riri5 import RIRI5 as riri #import de la version develop si module soil3ds est installe
except:
    import RIRI5 as riri

import RootDistrib as rtd
import RootMorpho2 as rt
import ShootMorpho as sh
import daily_loop as loop
import management_auto as mna
import IOtable
import IOxls
import random
import pandas as pd
import zipfile




#options de simulation
opt_residu = 1 #si 0, pas activation de mineralisation
opt_sd = 1 #1 #genere distribution des valeurs de parametres
opt_covar = 0# #definie matrice de cavariance a lire dans path_variance_matrix (0 opt_sd generere tirages independants)
opt_stressN = 1 #Active stress N; 1 = stress NNI actif (0= calcule, mais pas applique)
opt_stressW = 1 #Active stressW; 1 = stress FTSW actif (0= calcule, mais pas applique)
opt_ReadstressN = 0 # Force stress N to read input values - for debugging/calibration
opt_ReadstressW = 0 # Force stress FTSW to read input values - for debugging/calibration
opt_photomorph = 1 #1 #Activate photomorphogenetic effects on organ growth; 1 Actif (0= calcule, mais pas applique)
opt_stressGel = 1 #Active gel stress option below Tgel
opt_optT = 0 #option de calcul du cumul de temperature (0=betaD; 1=betaH; 2=lineaireD)
opt_PP = 1 #0 #Active photoperiodic effects (1 active; 0 inactive)
opt_Mng = 0 # type of management file to be read: 0: default observed file ; 1: automatic management file #must be consistent with the management file!
opt_ReadPP = 0 # Force photoperiod to read input values in management - for indoor experiment
visu_root=1 #1# pour visualisation/interpretation root
visu_shoot=1 #1# pour visualisation/interpretation shoot
visu_sol=0 #1# pour visualisation/interpretation sol
visu_solsurf=1 #0 pour visualisation du pattern
frDisplay = 0 #1 #sauvegarde de la derniere vue
movDisplay =0 # #sauvegarde toutes les vues pour faire un film
opt_zip = 0 #if 1, zip and delete the output csv files 
opt_verbose =1 #0, remove print in the console



#initialisation des variables globale de simulation
DOYdeb = 60#100#49#159#124#
DOYend = 150#335#180#202#231#335#610#120#250#244#282#
Rseed = 0#2#0 #random seed
deltalevmoy = 30 #degre.jours
deltalevsd = 15


cote = 40.#80.#100.#100#25.#25.#cm
nbcote = 8#1#10
optdamier = 4
typearrangement='damier8'#'homogeneous'#'random8'#'damier16'#'random16'
idscenar1 = 1#-1 #inferieur a zero=defaut et fait rien
idscenar2 = 1#-1 #inferieur a zero=defaut et fait rien
idscenar1_sd = 1
idscenar2_sd = 1


tresh_LA = 0.0015 # 0.0010=10cm2 #seuil de surface des feuilles pour separer les folioles dans la grille 3D
obstarac_ = None#array([[-0.5]*5, [-0.5]*5, [-0.75]*5, [-1.]*5, [-1.]*5]).transpose() #matice 2D de valeurs de profondeur d'obstacle en m #None #




## lecture fichier meteo
#faire une fonction??
meteo_path = os.path.join(path_leg,'meteo_exemple.xls')#'meteo_exemple_debugL_gl.xls')##r'H:\devel\grassland\grassland\L-gume\meteo_exemple2.xls'
ongletM = 'Lusignan30'#'DigitLuz10'#'Lusignan30'#'Lusignan302ans'#'DivLeg15'#'morpholeg15'#'combileg15'#'combileg16'#'Avignon30'#'exemple'#'morpholeg15'#'testJLD'#'competiluz'#
meteo = IOxls.read_met_file(meteo_path, ongletM)


## lecture fichier initialisation
inis_path = os.path.join(path_leg, 'Init_sol_exemple.xls')#'Initialisation_sol_exemple.xls')
ongletIn = 'Lusignan30_5x5'#'Lusignan30'#'morpholeg_rhizo'#'combileg15'#'combileg16'#'Lusignan30Irr'#'Avignon30IrrN'#'Avignon30'#'DivLeg15'#
inis = IOxls.read_plant_param(inis_path, ongletIn)


## lecture fichier plante
path_plante = os.path.join(path_leg,'Parametres_plante_exemple.xls')#'Parametres_plante_v5cLucas.xls')#'Parametres_plante_v18.xls')#'Parametres_plante_v9Lucas_debugL.xls')#r'H:\devel\grassland\grassland\L-gume\Parametres_plante_v5cLucas.xls' 
ongletP = 'Fix2'#'Orca'#'Fet'#'giga'#'solnu'#'Fix1'#'Fix'#'timbale'#'formica'#'canto'##'alfalfa'#'geno_test'#'G3'#'C1'#'8_2'#'kayanne'#'leo'#'G1'#'timbale'##
ongletPvois = 'nonFixSimTest'#'Orca2'#'OrcaVois'#'Fet'#'giga'#'solnu'#'nonFix1'#'nonFix0'#'alfalfa'#'geno_test'#'G3'#


## lecture fichier management (2 types possibles selon opt_Mng: obs/auto)
mn_path = os.path.join(path_leg,'management_exemple.xls')#'management_exemple3_debugL_gl.xls')#r'H:\devel\grassland\grassland\L-gume\management_exemple.xls'
ongletMn = 'Lusignan30IrrN2'#'DigitLuz10'#'Lusignan30IrrN2'#'Lusignan30IrrN2ans'#'DivLeg15'#'Lusignan30IrrN'#'illimite-sanscoupe'#'combileg15-irrigajusteeLUZTVMIN'#'combileg16-irrigajusteeMIN'#'Lusignan30'#'Avignon30IrrN'#'Avignon30'#
#mn_path = os.path.join(path_leg,'management_auto_exemple.xls')# exemple pour auto
#ongletMn = 'exemple'
if opt_Mng == 0:
    mng = IOxls.read_met_file(mn_path, ongletMn)
elif opt_Mng == 1: #Automatic management file
    mng_auto = IOxls.read_plant_param(mn_path, ongletMn)
    mng = mna.Build_mng_auto(meteo, mng_auto, path_plante, ongletP, DOYdeb, opt_optT)


#lecture des parametres du sol
path_sol = os.path.join(path_leg,'Parametres_sol_exemple.xls')#'Parametres_sol_exemple2_debugL_glbis.xls')#
ongletS = 'lusignan99'#'morpholeg'#'combileg2015vshallow'#'combileg16vshallow'#'ASCHYD11'#'DivLeg15'#
par_SN, par_sol = IOxls.read_sol_param(path_sol, ongletS)
par_SN['concrr'] = 0.#force eau de pluie / irrig a zero N, sinon apport 300 kg en irrigue!

#lecture scenario valeur moyenne (si changement de parametres)
mn_sc = os.path.join(path_leg,'liste_scenarios_exemple.xls')#'scenarios_planMorris.xls')#'liste_scenarios_exemple.xls')#(path_leg,'liste_scenarios.xls')
ongletScenar1 = 'Fix2'#'Orca'#'default'#'nonFixSimTest'#'default'#'formica'#
ongletScenar2 = 'nonFixSimTest'#'Orca2'#'default'#'OrcaVois'#'default'#'nonFix1'#'default'#'formica'#

# lecture scenario variabilite intra et variables associees
path_variance_geno = os.path.join(path_leg, 'exemple_sd.xls')
#variance_geno = pd.read_excel(path_variance_geno)
#ls_parname = list(variance_geno.columns[1:])
#ls_sdpar = list(pd.read_excel(path_variance_geno).iloc[(0)][ls_parname])
#moy_modif=3.4875000000000003

#lectrure matrice covariance variabilite intra
path_variance_matrix = os.path.join(path_leg, 'exemple_corr_matrix.xls')


# lecture fihier station
path_station = os.path.join(path_leg, 'stations_exemple.xls')
ongletSta = 'Lusignan'#'exemple'


#lecture fichiers et variables de sortie
path_outf = os.path.join(path_leg,'mod_susm.xls')#
outf = IOxls.read_plant_param(path_outf, 'output_files')
outfvar = IOxls.read_plant_param(path_outf, 'daily_outputs')
#faudait lie ca plus simplement avec table pandas



#chemin des fichiers de sortie (doivent etre declares avant de lancer le L-system, pour pouvoir l'appeller en dehors de L-py)
outvarfile = 'toto_.csv'#'vglg-toto.csv'#r'H:\devel\grassland\grassland\L-gume\toto.csv'
lsorgfile = 'lsAxes.csv'#r'H:\devel\grassland\grassland\L-gume\lsAxes.csv'
outimagefile = 'scene.bmp'#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
outHRfile = 'outHR.csv'#r'H:\devel\grassland\grassland\L-gume\outHR.csv'
outBilanNfile = 'BilanN.csv'#r'H:\devel\grassland\grassland\L-gume\BilanN.csv'
resrootfile = 'newres.csv'#r'H:\devel\grassland\newres.csv'
outsdfile = 'paramsd.csv'#file for distrubtion of parameters sd
outMngfile ='MngAuto.csv'#file for recording automatic management actions



#1 residu = listes de 1 element
#DOYres = DOYdeb+20#300 #jour d'ajout des residus -> pas utilise
#nb_res = 8# 4 types de residus par espece (4 compatiment du papier) * 2 especes #pas utilise jusque la? (force donc cycles boucle pas? ou  ajuster a 1 moment?)

#vAmount= [0.1]*nb_res#[20.]# T Fresh Weight.ha-1 (equivalent QRES)
#vCNRESt = [40.]*4+[40.]*4 #g.g-1 (equivalent CsurNres)
#vCNRESt = [16.]*4+[40.]*4 #g.g-1 (equivalent CsurNres)
#Vprop1 = [1./3., 1./3., 1./3.]+50*[0.] #distribution dans les horizons #-> change 27 en 50 pour etre sur d'avoir le nb d'horizon-> a adapter selon le vrai nbr d'horizons!!!
#vProps= [Vprop1]*nb_res#[Vprop1]#[Vprop1, Vprop1, Vprop1]
#vWC=[0.7]*nb_res# fraction d'eau des residu frais (equivalent de Crespc /(%)/100)
#vCC=[0.42]*nb_res# fraction de C des residus sec (equivalent de Crespc /(%)/100)
#vNmires = [0.00197]*nb_res# fraction de poids frais residu en azote mineral (equivalent de Nminres(%)/100)




#1 seul axe en developpemnt? -> arret
#PAR tresh a 1 ou au dessus fait tout s'arreter?? 0.999 marche..
#meme apres rayonnement 5 direc, peetites feuilles et PARtresh a 0.99 -> rayonnement local a l'air bon????
# par tresh dans l'autre sens 0.33 marche 0.01 OK


def init_glob_variables_sim(meteo, mng, DOYdeb, deltalevmoy, deltalevsd):
    
    ## station
    station = IOxls.read_plant_param(path_station, ongletSta) #ou lire ds fichier inis
    
    ## meteo du jour
    DOY=DOYdeb
    meteo_j = IOxls.extract_dataframe(meteo, ['TmoyDay','RG','Et0','Precip','Tmin','Tmax','Tsol'], 'DOY', val=DOY)
    meteo_j['I0'] = [0.48*meteo_j['RG'][0]*10000/(3600*24)]#flux PAR journalier moyen en W.m-2 / RG en j.cm-2
    mng_j = IOxls.extract_dataframe(mng, ['Coupe','Irrig', 'FertNO3','FertNH4','Hcut'], 'DOY', val=DOY)
    for k in list(meteo_j.keys()): meteo_j[k]=meteo_j[k][0]
    for k in list(mng_j.keys()): mng_j[k]=mng_j[k][0]
    meteo_j['durjour'] = sh.DayLength (station['latitude'],sh.DecliSun (DOY % 365))
    
    TT = 0
    TTsol = 0
    STEPS_ = meteo_j['TmoyDay']-5.#dTT(meteo_j['TmoyDay'], [ParamP[0]['Tdev']])# #variable remise  ajour chaque jour
    STEPSsol_ = meteo_j['Tsol']-5.
    ls_epsi = [0.]# [0.4, 0.4]##!! correspondance avec les nb de root systems!
    
    
    ##coupe
    TT_repousse = 0 #TT de la derniere coupev #resoud pb: TT utilise pour LAI pour NI revenait jamais a zero
    isTTcut = False
    wasTTcut = False
    #TTcutFreq = 18.*32#15.*32 #phyllochron
    isRegrowth = False #indicateur: est on a la pousse initiale ou bien plus tard?
    Hcut = 1.#3.#simple initialisation : est passe en lecture fichier management
    cutNB = 0
    
    ## divers
    start_time, past_time= time.time(), 0. #pour recuperer temps de calcul
    
    #distribution des retard a levee
    #deltalevmoy = 30 #degre.jours
    #deltalevsd = 15
    test_retard = []#pour gerer un decalage a la levee/reprise
    
    for i in range(510): test_retard.append(max(0,random.gauss(deltalevmoy,deltalevsd)))#test_retard.append(random.uniform(0,60))
    #for i in range(138): test_retard.append(0)#pas de retard.
    # a affectr a ['TT']!!
    
    return DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut,wasTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard, station



def init_ParamP(path_plante, ongletP, ongletPvois, nbcote, type='homogeneous', opt=4, ongletScenar1='default', ongletScenar2='default',idscenar1=1, idscenar2=1, mn_sc=None):
    
    #1) cree liste des paramtres plante (1dico par plante)
    #nbcote = nombre de plante sur un cote en supposant repartition homogene
    g4 = IOxls.read_plant_param(path_plante, ongletP)
    g4 = IOxls.modif_param(g4, ongletP, ongletScenar1, idscenar1, mn_sc=mn_sc)
    g5 = IOxls.read_plant_param(path_plante, ongletPvois)
    g5 = IOxls.modif_param(g5, ongletPvois, ongletScenar2, idscenar2, mn_sc=mn_sc)
    if type == 'homogeneous': #cas d'un couvert monospe homogene
        ParamP = [g4]*nbcote*nbcote
    elif type == 'damier8' or type == 'random8':#damier binaire 64 plantes
        ParamP = sh.damier8(g4,g5,opt=opt)
        if nbcote!=8 and opt_verbose==1:
            print('Warning! : damier8 option is for a 64 plant design')
    elif type == 'damier16' or type == 'random16':#damier binaire 256 plantes
        ParamP = sh.damier16(g4,g5,opt=opt)
        if nbcote!=16 and opt_verbose==1:
            print('Warning! : damier16 option is for a 256 plant design')
    elif type == 'row4':#4 rangs - 500pl.m-2
        ParamP, cart_ = sh.row4(g4,g5,nbprow= nbcote, opt=opt)
    else:#defautl= force nb plante comme nbcote
        ParamP = [g4]*nbcote
        #ParamP = [g4]*10#*2#*30#[g6, g4, g6, g4, g6, g4, g6]#[g6,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4]#[g4] 
        #[g1, g2, g3]#[g4, g5, g5, g5, g5, g5, g5] 
    
    #2) ajout variabilite sd si opt_sd==1 (variabilite intra) ; possible seulement si pas analyse de sensibilite (onglet scenar=default)
    #test pour esp 1, Len avec sd=0.5
    #ls_sdpar = [0.5] #ecart type parametre - a passer via un fichier d'entree comme scenar? autrement (multivarie ou directement dans fichier parametre plante?)
    #ls_parname = ['Len'] #liste a recuperer via un fichier d'entree
    
    if opt_sd == 1:
        #test modif bea
        sd_fichier_g4=pd.read_excel(path_variance_geno, sheet_name=ongletP)
        ls_parname_g4 = list(sd_fichier_g4.columns) [1:] #liste les noms de colonne a  partir de la deuxieme
        ls_sdpar_g4 = sd_fichier_g4.loc[sd_fichier_g4["id_scenario"] == idscenar1_sd][ls_parname_g4][0:]
        ls_sdpar_g4 = ls_sdpar_g4.iloc[0]
        
        sd_fichier_g5 = pd.read_excel(path_variance_geno, sheet_name=ongletPvois)
        ls_parname_g5 = list(sd_fichier_g5.columns) [1:] #liste les noms de colonne a  partir de la deuxieme
        ls_sdpar_g5 = sd_fichier_g5.loc[sd_fichier_g5["id_scenario"] == idscenar2_sd][ls_parname_g5][0:]
        ls_sdpar_g5 = ls_sdpar_g5.iloc[0]
        
        #print(ls_sdpar_g5, ls_sdpar_g4)
        #print(ls_parname_g5, ls_parname_g4)
        
        #ParamP = IOxls.modif_ParamP_sd(ParamP, g4, ls_parname= ['Len'], ls_sdpar= [0.5])
        #ParamP = IOxls.modif_ParamP_sd(ParamP, g5, ls_parname= ['Len'], ls_sdpar= [0.5])
        #ParamP = IOxls.modif_ParamP_sd(ParamP, g4, ls_parname=  ls_parname_g4, ls_sdpar=ls_sdpar_g4)
        #ParamP = IOxls.modif_ParamP_sd(ParamP, g5, ls_parname=  ls_parname_g5, ls_sdpar=ls_sdpar_g5)
        #print(df1, df2)
        
        if opt_covar == 1:
            #lecture de deux matrices de correlation -> bon onlet / scenario (id colonne dedie) dans bon fichier "corr_Matrix" -> a faire!
            # idscenar1_sd et idscenar2_sd: meme id que pour opt_sd!
            covar_fichier_g4 = pd.read_excel(path_variance_matrix, sheet_name=ongletP)
            cor_g4 = array(covar_fichier_g4[covar_fichier_g4['id_scenario'] == idscenar1_sd]["correlation"])
            size_mat4 = int(sqrt(len(cor_g4)))
            cor_mat4 = cor_g4.reshape((size_mat4,size_mat4))
            
            covar_fichier_g5 = pd.read_excel(path_variance_matrix, sheet_name=ongletPvois)
            cor_g5 = array(covar_fichier_g5[covar_fichier_g5['id_scenario'] == idscenar2_sd]["correlation"])
            size_mat5 = int(sqrt(len(cor_g5)))
            cor_mat5 = cor_g5.reshape((size_mat5,size_mat5))
            
            #print('covar g4', cor_mat4, cor_mat5) 
            ParamP, df1 = IOxls.modif_ParamP_sdMulti(ParamP, g4, ls_parname=  ls_parname_g4, ls_sdpar=ls_sdpar_g4, corrmatrix=cor_mat4)
            ParamP, df2 = IOxls.modif_ParamP_sdMulti(ParamP, g5, ls_parname=  ls_parname_g5, ls_sdpar=ls_sdpar_g5, corrmatrix=cor_mat5)
            
        else: 
            #defaut = no matrix of covariance = independant
            ParamP, df1 = IOxls.modif_ParamP_sdMulti(ParamP, g4, ls_parname=  ls_parname_g4, ls_sdpar=ls_sdpar_g4, corrmatrix=None)
            ParamP, df2 = IOxls.modif_ParamP_sdMulti(ParamP, g5, ls_parname=  ls_parname_g5, ls_sdpar=ls_sdpar_g5, corrmatrix=None)
    
    
    
    #3) ajout de parametre 'recalcule'
    #roots
    for nump in range(len(ParamP)):
      #update des parametre racinaire
      rt.update_root_params(ParamP[nump]) #'lsDrac', 'nb_ordre_rac', 'lsVrac', 'lsDemanDRac', 'LDs'
      #print 'LDs', ParamP[nump]['LDs2'], ParamP[nump]['LDs3'], ParamP[nump]['lsDrac'], ParamP[nump]['GDs2'], ParamP[nump]['GDs3']
      ParamP[nump]['profilRoot'] = rt.rootTropism(ParamP[nump]['IncRoot0'], ParamP[nump]['g_root'], segment=0.3, Long=300.)
    
    #shoot profiles
    ParamP = sh.update_shoot_params(ParamP)
    
    nbplantes = len(ParamP)
    return ParamP, nbplantes




def init_scene(ParamP, inis, cote, nbcote, station, type='damier8'):
    #initialoise la scene: arrangement des plantes (carto), discretisation souterraine, discretisation aerienne
    # 1) CARTO
    distplantes = cote/nbcote#1. #cm
    
    ## pour ilot
    #carto = [array([0.,0.,0.]), array([distplantes,0.,0.]),array([-distplantes,0.,0.]),array([0.5*distplantes,0.866*distplantes,0.]),array([-0.5*distplantes,0.866*distplantes,0.]), array([0.5*distplantes,-0.866*distplantes,0.]), array([-0.5*distplantes,-0.866*distplantes,0.])]#, array([-10.,0.,0.]), array([0.,7.,0.])] #liste des localisations (1pt par plante) -> a lire en fichier #LF - cos (pi/3) = 0.5   sin (pi/3) = 0.866
    
    #carto = [array([0.,0.,0.]), array([distplantes,0.,0.]),array([-distplantes,0.,0.]),array([0.5*distplantes,0.866*distplantes,0.]),array([-0.5*distplantes,0.866*distplantes,0.]), array([0.5*distplantes,-0.866*distplantes,0.]), array([-0.5*distplantes,-0.866*distplantes,0.]),array([2*distplantes,0.,0.]),array([-2*distplantes,0.,0.]),array([2*0.5*distplantes,2*0.866*distplantes,0.]),array([-2*0.5*distplantes,2*0.866*distplantes,0.]), array([2*0.5*distplantes,-2*0.866*distplantes,0.]), array([-2*0.5*distplantes,-2*0.866*distplantes,0.])] #carto13
    
    ## pour champ en rangs 
    #yyy = [-15]*9+[0]*9+[15]*9
    #xxx = range(-20,25,5)*3
    #yyy = [-15]*9+[-7.5]*9+[0]*9+[7.5]*9+[15]*9+[22.49]*9
    #xxx = range(-20,25,5)*6
    #yyy = [-15]*5+[0]*5+[15]*5
    #xxx = range(-20,25,10)*3
    #yyy = [-15]*2+[0]*2+[15]*2
    #xxx = range(-20,25,25)*3
    #yyy = [-15]*1+[0]*1+[15]*1
    #xxx = range(-20,25,60)*3
    #yyy = [-15]*23+[-7.5]*23+[0]*23+[7.5]*23+[15]*23+[22.49]*23
    #xxx = range(-20,25,2)*6
    
    #pour grand rhizotron
    #yyy = [-12.25, 4.4, 21.05]
    #xxx = [-10.75, -8.35, -5.95, -3.55, -1.15, 1.25, 3.65, 6.05, 8.45, 10.85]
    
    
    if type=='row4': #pour carre 4 rangs heterogenes
        Param_, carto = sh.row4(1,2,Lrow=cote , nbprow=nbcote)
    elif type=='random8' or type=='random8':
        #pour tirage random
        carto = sh.random_planter(nbcote*nbcote, cote, cote)
    else:
        #pour carre distance homogene
        carto = sh.regular_square_planter(nbcote, distplantes)
        
    
    
    # 2) definition du pattern et discretisation sol
    pattern8 = [[0,0], [cote,cote]]
    #pattern8 =[[min(xxx)-dp,min(yyy)-dp], [max(xxx)+dp,max(yyy)+dp]]
    #[[-2.5,-2.5], [2.5,2.5]]#[[-5.,-5.],[5.,5.]]#[[-2.5,-2.5], [5,5]]#[[-12.5,-12.5],[12.5,12.5]]
    #pattern8 = [[-22.3/2.,-49.5/2.], [22.3/2.,49.5/2.]]#pattern.8 rhizotron equivalent (cm)
    
    Lsol = max((pattern8[1][0]-pattern8[0][0])/100., (pattern8[1][1]-pattern8[0][1])/100.)#m
    largsol = min((pattern8[1][0]-pattern8[0][0])/100., (pattern8[1][1]-pattern8[0][1])/100.)#m
    surfsolref = Lsol*largsol #m2
    dz_sol = inis['dz_sol']#4.#5. #cm
    ncouches_sol = int(inis['ncouches_sol'])#4#10#30
    prof_sol_max = ncouches_sol*dz_sol#80.
    
    discret_solXY = list(map(int, inis['discret_solXY']))#[10,10]# nb de discretisation du sol en X et en Y
    lims_sol = rtd.lims_soil(pattern8, dxyz=[[Lsol/discret_solXY[0]]*discret_solXY[0], [largsol/discret_solXY[1]]*discret_solXY[1], [dz_sol/100.]*ncouches_sol])
    
    
    #3) discretisation au niveau aerien
    #creation des grid3D pour calcul de rayonnement
    ls_gammagroup = list(map(int, riri.get_lsparami(ParamP, 'gammagroup')))
    setp = list(set(ls_gammagroup)) #set equivalent fonction r.unique!
    n_gamagroup = len(setp)
    
    for nump in range(len(ParamP)):#ajout a chaque plante de son id grille dans ParamP
        ParamP[nump]['id_grid'] = setp.index(int(ParamP[nump]['gammagroup']))  #pour savoir id de grille de la plante
    
    na, dxyz, lims_aer, origin_grid, surf_refVOX = riri.def_na_lims(pattern8, station['dz_aerien'], station['Hmaxcouv'],opt= station['opt1D3D'])#'1D' 
    #na, dxyz, lims_aer, origin_grid, surf_refVOX = riri.def_na_lims(pattern8, dz_aerien, Hmaxcouv,opt='1D') #version 1D, comme avant
    m_lais = zeros([n_gamagroup, na[2], na[1], na[0]]) #ngamma, Z,Y,,X
    m_lais_construct = deepcopy(m_lais) #pour contsruction du m_lais a t+1
    triplets = riri.get_ls_triplets(m_lais[0], opt=station['sky'])#'VXpXmYpYm')#opt='V')#
    
    #liste des k_teta (coeff extinction directionnels) par entite
    ls_dif = [] 
    #prepa des k_teta par entite
    for i in setp:
        nump = ls_gammagroup.index(i) #retrouve numero de plante de premiere occurence de gammagroup
        ls_dif.append(ParamP[nump]['k_teta_distf'])
    
    res_trans, res_abs_i = [],[]
    res_rfr = []
    
    
    return carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr
    #par logique, passer cote et nbcote dans ini?





def init_sol(inis, meteo_j, par_sol, par_SN, Lsol, discret_solXY, dz_sol, pattern8, opt_residu, obstarac =None):
    """ soil initialisation from L-py"""
    #vecteurs d'initialisation du sol
    Tsol = meteo_j['Tsol']#15. #degresC
    num_nb = list(map(int, inis['num_nb']))#[6,6,18] #nbr de couche de chaque num de sol 
    vsoilnumbers = [1]*num_nb[0]+[2]*num_nb[1]+[3]*num_nb[2] #convention autorise 3 types d'horizon max
    #vDA = [par_SN['DA'][0]]*num_nb[0] + [par_SN['DA'][1]]*num_nb[1] + [par_SN['DA'][2]]*num_nb[2] #densite apparente de sol
    vCN = [par_SN['CN0_30']]*num_nb[0] + [par_SN['CN30_60']]*num_nb[1] + [par_SN['CN60_90']]*num_nb[2] #maxi 3 horizons
    vMO = [par_SN['MO0_30']]*num_nb[0] + [par_SN['MO30_60']]*num_nb[1] + [par_SN['MO60_90']]*num_nb[2] #maxi 3 horizons
    vARGIs = [par_SN['ARGIs0_30']]*num_nb[0] + [par_SN['ARGIs30_60']]*num_nb[1] + [par_SN['ARGIs60_90']]*num_nb[2]
    vCALCs = [par_SN['CALCs']]*ncouches_sol
    vNH4 = inis['NH4']#[2.]*ncouches_sol # #!! kg d'N.ha-1 (entree de STICS)
    vNO3 = inis['NO3']#[0.]*ncouches_sol
    HRpinit = inis['HRp']#[]
    if min(HRpinit)<0: #code -1 pour pas d'initialisation
        HRpinit = []
        
    vDA=[]
    for i in vsoilnumbers:
        vDA.append(par_sol[str(i)]['DA'])
        
    
    #vsoilnumbers = [1]+[2]*3+[3]*13+[4]*13 #numeros de sol du profil -> mesures acsyd11
    #vDA = [1.81]+[1.31]*3+[1.37]*13+[1.42]*13 #densite apparente de sol (mesure pesees initial aschyd11)
    #vCN = [par_SN['CN0_30']]*ncouches_sol #maxi 90cm en strates de 5cm
    #vMO = [par_SN['MO0_30']]*ncouches_sol #maxi 90cm en strates de 5cm
    #vARGIs = [par_SN['ARGIs']]*ncouches_sol #maxi 90cm
    #vCALCs = [par_SN['CALCs']]*ncouches_sol
    #vNH4 = [2.]*ncouches_sol # #!! kg d'N.ha-1 (entree de STICS)
    #coeff = 0.#0.09#coeff perte ressuyage -> a ajuster pour avoir environ 600 kg N.ha-1
    #vNO3 = [91.*coeff]*ncouches_sol # kg d'N.ha-1 (entree de STICS)
    #vNO3 = array([16.96, 16.07, 15.17, 33.92, 33.92, 33.92, 33.92, 62.49, 82.13, 89.27, 76.77, 107.13, 124.98, 142.84, 124.98, 142.84, 160.69, 151.76, 151.76, 142.84, 178.55, 133.91, 98.20, 89.27, 83.92, 89.27, 73.20, 89.27, 87.45, 62.49])*coeff #issu du profil en sol nu
    #HRpinit = [25.5,26.,25.,25.5,26.,26.,26.,26.5,26.5,27.,27.,27.,27.5,27.5,27.5,27.5,27.5,29,29,29,29,29,29,29,29,30,30,30,30,30]#-> mesures ahscyd au jour 195 (140711) -> init sol nu
    
    
    
    ## soil initialisation
    S = solN.SoilN(par_sol, par_SN, soil_number = vsoilnumbers, dxyz = [[Lsol/discret_solXY[0]]*discret_solXY[0], [largsol/discret_solXY[1]]*discret_solXY[1], [dz_sol/100.]*ncouches_sol], vDA=vDA, vCN=vCN,vMO=vMO, vARGIs = vARGIs,vNO3=vNO3,vNH4=vNH4, vCALCs=vCALCs, Tsol=Tsol,pH=par_SN['pH'], ZESX=par_SN['ZESX'] , CFES=par_SN['CFES'],obstarac=obstarac, pattern8=pattern8)
    
    
    if HRpinit!=[]:#initialise humidite si un vecteur est fourni
        S.init_asw(HRp_init=HRpinit) 
    
    
    #lims_sol = rtd.lims_soil(pattern8, dxyz=[[Lsol], [largsol], [dz_sol/100.]*ncouches_sol])
    #if opt_residu==1:#initialisatio de residus
    #    #S.init_residues(vCNRESt, vAmount, vProps, vWC, vCC)
    #    pass
    
    
    #print 'sol', sum(S.m_NO3), sum(S.m_NH4), sum(S.m_QH20fc)-sum(S.m_QH20wp)
    
    #Uval = 0.9*2.61#(epaisseur de sol* mm d'eau dans 1cm) #U quantite d'eau dans une couche superieure en mm (5 par default)
    #Uval = par_SN['q0']*0.1*sum(S.m_QH20fc[0])*surfsolref / (S.dxyz[2][0]*100.)#(epaisseur de sol (cm)* mm d'eau dans 1cm) #U quantite d'eau dans une couche superieure en mm (5 par default)
    Uval = par_SN['q0']
    stateEV = [0.,0.,0.] #pour le calcul de l'evaporation du sol (memoire du cumul evapore depuis derniere PI)
    HXs = par_sol[str(vsoilnumbers[0])]['teta_fc']#humidite a la capacite au champ de l'horizon de surface
    b_= solN.bEV(par_SN['ACLIMc'], par_SN['ARGIs'], HXs)#HXs=0.261)#1.#valeur empirique tres proche#0.1#0.63#0.63
    #print (par_SN['q0'],'Uval', ' b ', Uval, b_, sum(S.m_QH20fc[0]), surfsolref , (S.dxyz[2][0]*100.))
    
    
    return S, Tsol, Uval, stateEV, b_


def init_plant_residues(S, opt_residu, ParamP):
    """ separate initialisation of plant residue from plant files"""
    if opt_residu==1:#initialisatio de residus
        
        #number of groupes?
        ls_groupres = list(map(int, riri.get_lsparami(ParamP, 'groupe_resid')))
        setg = list(set(ls_groupres)) #set equivalent fonction r.unique!
        n_groupres = len(setg)
        #recup 1 jeu de param pour chaque groupe
        CNRES, CC, WC, Nmires = [], [], [], []
        for i in range(len(setg)):
            for nump in range(nbplantes):
                if ParamP[nump]['groupe_resid']==setg[i]:
                    ParamP[nump]['CNRES'] = [ParamP[nump]['CNRESlf'], ParamP[nump]['CNRESst'], ParamP[nump]['CNRESr'], ParamP[nump]['CNRESpiv']]
                    CNRES = CNRES + ParamP[nump]['CNRES']
                    CC = CC + ParamP[nump]['CC']
                    WC = WC + ParamP[nump]['WC']
                    Nmires = Nmires + ParamP[nump]['Nmires']
                    #print ('par',CNRES, CC, WC, Nmires)
                    break
        
        if len(setg)==1: #si 1 seul grope, met qd meme un deuxieme residu de meme type pour pas planter
            for nump in range(nbplantes):
                if ParamP[nump]['groupe_resid']==setg[0]:
                    ParamP[nump]['CNRES'] = [ParamP[nump]['CNRESlf'], ParamP[nump]['CNRESst'], ParamP[nump]['CNRESr'], ParamP[nump]['CNRESpiv']]
                    CNRES = CNRES + ParamP[nump]['CNRES']
                    CC = CC + ParamP[nump]['CC']
                    WC = WC + ParamP[nump]['WC']
                    Nmires = Nmires + ParamP[nump]['Nmires']
                    #print ('par',CNRES, CC, WC, Nmires)
                    break
        #Nmires not used???
        
        #distrib dans le sol en dur! 
        nb_res = len(CNRES)# 4 types de residus par espece (4 compatiment du papier) * 2 especes #pas utilise jusque la? (force donc cycles boucle pas? ou  ajuster a 1 moment?)
        vAmount= [0.1]*nb_res#[20.]# T Fresh Weight.ha-1 (equivalent QRES)
        Vprop1 = [1./3., 1./3., 1./3.]+50*[0.] #distribution dans les horizons #-> change 27 en 50 pour etre sur d'avoir le nb d'horizon-> a adapter selon le vrai nbr d'horizons!!!
        vProps= [Vprop1]*nb_res#[Vprop1]#[Vprop1, Vprop1, Vprop1]
        
        #S.init_residues(vCNRESt, vAmount, vProps, vWC, vCC)
        S.init_residues(CNRES, vAmount, vProps, WC, CC)
        return CC


def init_variables_plantes(ParamP, nbplantes):
    global epsilon
    # 1) INVAR
    #dico des variables interne instantanes par plante  utilises dans differents calculs ou preparant des sorties
    
    ## SurfPlante: liste (par nump) de liste de surface de feuille verte au temps t 
    ## PARaPlante: liste (par nump) de liste de PARa feuille verte au temps t
    ## PARiPlante: liste (par nump) de liste de PARi feuille verte+senescente au temps t
    ## parap (anciens dpar / ls_parap): liste de delta de PARa du jour par plante (feuilles vertes) (utilise pour modulation racines notamment)
    ## parip: liste de delta de PARa du jour par plante (feuilles vertes+senescente)
    ## Hplante : liste de hauteur max des plantes
    ## Dplante: liste de diametre max des plantes
    ## Mrac_fine: Liste (par step/jour) de liste de delta de MSracines fines par plante
    ## Mpivot: Liste (par step/jour) de liste de delta de MSpivot par plante
    ## Maerien: Liste (par step/jour) de liste de delta de MSaerien par plante
    ## MS_rac_fine: liste des MSracines_fines cumule au temps t par plante
    ## MS_pivot: liste des MSpivot cumule au temps t par plante
    ## MS_aerien: liste des MSaerien cumule au temps t par plante
    ## MS_aer_cumul: liste des MSaerien cumule, SANS REMISE A ZERO A LA COUPE, pour calcul d'allocation aux racines.
    ## RLTot: liste de total fine root length par plante(m)
    ## Rdepth: liste de profondeur max du pivot par plante (cm)
    ## DiampivMax: liste de diametre max des pivot par plante
    ## countSh: Liste de nb tiges I cumule emis par plante depuis levee (tout A emis de B) - Compteur de Tige I
    ## countShExp: Liste de nb tiges I cumule emis par plante depuis levee par voie B->BDA - Compteur de bourgeons au niveau de la courrone  
    ## NBsh : Liste par plante de nb tiges (I ou II) avec nb phytomeres>50% du max
    ## NBI : Liste par plante de nombre de phytomere maxi sur tiges I ayant >75% du max
    ## NBD1 : Liste par plante de nombre de bourgeons dormants D()
    ## NBB : Liste par plante de nombre de bourgeons actifs B()
    ## NBBexp : Liste par plante de nombre de bourgeons actifs B() de statut exp = generateur de nouveaux axes
    ## lsA : Liste par plante de numero de nsh (B() et A()) actifs ou non
    ## lsAPrev : Liste par plante de numero de nsh (B() et A()) actifs ou non au step n-1 : utilise pour maintenir en dormance les D()
    ## lsApexMort : Liste par plante de numero de nsh (A()) mort
    ## DemandN_Feuil : Liste par plante de quantite d'N des feuille pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Pet : Liste par plante de quantite d'N des petioles pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Stem : Liste par plante de quantite d'N des tiges pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Tot : Liste par plante de quantite d'N totales pour satisfaire 1 INN = 1 (g.plant-1)
    ## R_DemandC_Root : Liste par plante de ratio offre/demande C pour croissance des racines
    ## RLen1, Len2,RLen3,RLen4,RLentot : Liste par plante de longueur cumulee de racine d'ordre 1, 2, 3 et total (m)
    ## SRL: Liste par plante de specific root length (m.g-1)
    ## phmgPet: Liste par plante d'effet maximum d'allongement du a la photomorphogenese (petioles)
    ## phmgEntr: Liste par plante d'effet maximum d'allongement du a la photomorphogenese (entrenoeuds)
    ## phmgPet_m: Liste par plante d'effet maximum de reduction de croissance du a la photomorphogenese (petioles)
    ## phmgEntr_m: Liste par plante d'effet maximum de reduction de croissance du a la photomorphogenese (entrenoeuds)
    ## dMSenFeuil: Liste par plante des delta de biomasse de feuille senescent (g.plant-1)
    ## dMSenTige: Liste par plante des delta de biomasse de tige (entre-noeud et petiole) senescent (g.plant-1)
    ## R_DemandC_Shoot: Liste par plante de ratio offre/demande C pour croissance minimu des tiges
    ## NBphyto: Liste par plante de nbr de phytomeres compte sur la nase des entre-noeuds presents
    ## germinaltion: liste of a logical value: 0=no germination, 1=germination, 2=1feuille visible
    ## TTphyllo: liste of phyllochronic time by plant
    
    #! RLentot va remplacer RLTot!
    
    
    invar = {'SurfPlante':[], 'PARaPlante':[], 'PARiPlante':[], 'PARaPlanteU':[],'Hplante':[], 'Dplante':[], 'RLTot':[], 'RDepth':[], 'parap':[], 'parip':[], 'Mrac_fine':[], 'Mpivot':[], 'Maerien':[], 'Mfeuil':[],'Mcoty':[],'MS_rac_fine':[], 'MS_pivot':[], 'MS_aerien':[],'MS_feuil':[],'MS_aer_cumul':[], 'Mtot':[], 'MS_tot':[], 'DiampivMax':[], 'countSh':[], 'NBsh':[], 'NBI':[], 'DemandN_Feuil':[], 'DemandN_Pet':[], 'DemandN_Stem':[],'DemandN_Tot':[], 'DemandN_TotAer':[], 'NBD1':[], 'NBB':[], 'countShExp':[],'lsA':[],'lsAPrev':[],'lsApexMort':[], 'NBBexp':[], 'R_DemandC_Root':[],'RLen1':[], 'RLen2':[],'RLen3':[],'RLentot':[],'SRL':[],'phmgPet':[],'phmgEntr':[],'phmgPet_m':[],'phmgEntr_m':[],'firstleaf':[], 'Naerien':[], 'Npc_aer':[], 'Npc_piv':[], 'Npc_rac_fine':[],'Nuptake_sol':[],'NNI':[], 'Ndfa':[], 'Qfix':[], 'TT':[],'TTsol':[], 'dTT':[], 'dTTsol':[], 'dMSenFeuil':[],'dMSenTige':[], 'R_DemandC_Shoot':[],'RUEactu':[], 'DemCp':[],'DemCp_lf':[], 'DemCp_in':[], 'DemCp_pt':[], 'L_Sp':[],'remob':[],'Nrac_fine':[], 'Npivot':[],'dRLen2':[],'dRLen3':[],'dMSenRoot':[],'dRLenSentot':[], 'RLTotNet':[], 'MS_rac_fineNet':[],'perteN_rac_fine':[],'Surfcoty':[],'NBphyto':[],'germination':[],'MSgraine':[], 'Ngraine':[],'dMSgraine':[],'dNgraine':[], 'NBapexAct':[],'NreservPiv':[],'rgeq':[], 'transpi':[], 'cumtranspi':[],'aliveB':[],'isGelDam':[],'dMSmortGel':[],'dNmortGel':[],'dTTphyllo':[],'TTphyllo':[], 'Udev':[],'Udevstress':[],'Udevsol':[],'TTudev':[],'RUEpot':[],'countGelD':[]} 
    
    for i in range(nbplantes): invar['SurfPlante'].append([]); invar['PARaPlante'].append([]); invar['PARiPlante'].append([]); invar['lsA'].append([]);invar['lsAPrev'].append([]);invar['lsApexMort'].append([])
    
    for i in range(nbplantes): invar['Hplante'].append(0.); invar['Dplante'].append(0.);invar['RLTot'].append(0.); invar['RDepth'].append(0.);invar['parap'].append(0.); invar['parip'].append(0.);invar['PARaPlanteU'].append(0.);invar['DiampivMax'].append(0.1); invar['countSh'].append(0);invar['NBsh'].append(0.);invar['NBI'].append(0.);invar['DemandN_Feuil'].append(0.);invar['DemandN_Pet'].append(0.);invar['DemandN_Stem'].append(0.);invar['DemandN_Tot'].append(0.);invar['NBD1'].append(0);invar['NBB'].append(0); invar['countShExp'].append(0);invar['NBBexp'].append(0); invar['R_DemandC_Root'].append(0);invar['RLen1'].append(0);invar['RLen2'].append(0);invar['RLen3'].append(0);invar['RLentot'].append(0);invar['SRL'].append(100.);invar['phmgPet'].append([1.]);invar['phmgEntr'].append([1.]);invar['phmgPet_m'].append([1.]);invar['phmgEntr_m'].append([1.]);invar['firstleaf'].append(float("inf"));invar['MS_aer_cumul'].append(0.); invar['NNI'].append(1.); invar['Ndfa'].append(1.); invar['TT'].append(0.);invar['TTsol'].append(0.);invar['dTT'].append(0.);invar['dTTsol'].append(0.);invar['dMSenFeuil'].append(0.);invar['dMSenTige'].append(0.);invar['R_DemandC_Shoot'].append(1.);invar['DemCp'].append(0.);invar['DemCp_lf'].append(0.);invar['DemCp_in'].append(0.);invar['DemCp_pt'].append(0.);invar['MS_pivot'].append(0.);invar['remob'].append(0.);invar['RLTotNet'].append(0); invar['MS_rac_fineNet'].append(0);invar['perteN_rac_fine'].append(0);invar['NBphyto'].append(0);invar['germination'].append(0);invar['dMSgraine'].append(0.);invar['dNgraine'].append(0.);invar['NBapexAct'].append(0); invar['NreservPiv'].append(0);invar['rgeq'].append(0);invar['cumtranspi'].append(0.);invar['aliveB'].append(0.);invar['isGelDam'].append(0);invar['dMSmortGel'].append(0.);invar['dNmortGel'].append(0.);invar['dTTphyllo'].append(0.);invar['TTphyllo'].append(0.);invar['Udev'].append(0.);invar['Udevstress'].append(0.);invar['Udevsol'].append(0.);invar['TTudev'].append(0.);invar['countGelD'].append(10.);
    
    PG = array(riri.get_lsparami(ParamP, 'PMG'))/1000.
    invar['MSgraine'] = PG.tolist()
    invar['Mtot'].append(PG.tolist())
    invar['Ngraine'] = array(PG)*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.
    
    
    #invar['Maerien'].append(array(PG)*0.)
    #invar['Mpivot'].append(array(PG)*0.)
    #invar['Mfeuil'].append(array(PG)*0.)
    #invar['Mrac_fine'].append(array(PG)*0.)
    
    #initialisation avec des epsilon pour pas que ca bug?
    epsilon = 10e-10#10e-15
    frac_coty_ini = array(riri.get_lsparami(ParamP, 'frac_coty_ini')) #0.5 ##a passer en parametre?
    PG = array(PG)*epsilon
    
    invar['Maerien'].append(array(PG)*frac_coty_ini) #4/5 va aerien
    invar['Mcoty'] = array(PG)*frac_coty_ini #dans les cotyledons
    invar['Mrac_fine'].append(array(PG)*(1.-frac_coty_ini)*array(riri.get_lsparami(ParamP, 'frac_rac_fine')))
    invar['Mpivot'].append(array(PG)*(1.-frac_coty_ini)*(1. - array(riri.get_lsparami(ParamP, 'frac_rac_fine'))))
    
    invar['Mfeuil'].append(array(PG)*frac_coty_ini) #tout aerien dans feuil
    invar['Naerien'] = array(PG)*frac_coty_ini*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    invar['Nrac_fine'] = array(PG)*(1.-frac_coty_ini)*array(riri.get_lsparami(ParamP, 'frac_rac_fine'))*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    invar['Npivot'] = array(PG)*(1.-frac_coty_ini)*(1. - array(riri.get_lsparami(ParamP, 'frac_rac_fine')))*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    #Mtige pas explicite pour le moment
    
    # 2) INVAR_SC: variables a autres echelle que plante (un dico par echelle des surface, surface verte, PARa cumules)
    ## 3 echelles: plante = 'plt', tige ramifiee ='sh', Axe = 'ax'
    ## Surf: 
    ## SurfVerte: 
    ## PARaF:
    ## MaxPiv: dictionnaire par cle d'axe de biomasse cumulee par pivot
    ## DiampivMax: dictionnaire par cle d'axe de diametre max de pivot
    ## AgePiv: dictionnaire par cle d'axe d'age des pivot en TT
    
    invar_sc = {'plt':{}, 'sh':{}, 'ax':{}}
    #reorganiser invar sur la base de ces 3 echelles??
    invar_sc['ax']['MaxPiv']={}
    invar_sc['ax']['DiampivMax']={}
    invar_sc['ax']['AgePiv']={}
    invar_sc['ax']['DemCRac']={}
    invar_sc['ax']['OfrCRac']={}
    invar_sc['ax']['QDCRac']={}
    invar_sc['ax']['QDCmoyRac']={} #QD moyen integre dans le temps par pivot
    invar_sc['ax']['StressHRac']={}
    invar_sc['ax']['PonderStressHRac']={}
    invar_sc['ax']['StressHmoyRac']={}#stress hydrique moyen des racines par pivot integre dans le temps
    invar_sc['ax']['NRac']={}#liste de nb d'apex par ordre pour chaque pivot
    invar_sc['ax']['dlRac']={}#delta de longueur des racines par ordre
    invar_sc['ax']['cumlRac']={}#cumul de longueur de racine par ordre
    
    #pour stocker NI max
    invar_sc['sh']['MaxNI']={}#dev max des axes primaires -> pour gerer vitesse de redemarrage des pivots
    
    #3) Autres variables globales utilisees ds calcul
    ## lsAxes: liste d'apex I(axes) actifs (utilise dans calcLeafStemRatio)
    ## lsApex: liste d'apex I et II actifs (utilise dans calcNB_NI et cumul_lenIN)
    ## lsApexStop : liste d'apex I et II a l'arret 
    ## lsApexAll : liste de tous les apex I et II
    ## lsOrgans: liste des organes (Lf/Stp/In/Pet) sur tous les axes (utilise dans cumul_lenIN, calcOffreC, calcDemandeC) (ancien lsActiveAxes)
    lsAxes = []
    lsApex = []
    lsApexStop = []
    lsApexAll = []
    lsOrgans =[['TT','organ','nump', 'nsh', 'rank', 'rankp', 'strate', 'surf', 'PARaF','statut','age','ordre','l','Long','DOY','cutNB', 'Larg']]
    savelsOrgans=[]
    #for i in range(nbplantes): lsOrgans.append([]) #faire une liste d'organe par plante??
    
    
    #4)#initialisation des ls_systrac (#pour recuperer les enveloppes de racine par plante)
    ls_systrac = {} 
    for i in range(nbplantes):ls_systrac[i]=[]
    
    #5) initialisation des indices de stress par plante a 1. (devrait passer dans invar)
    ls_ftswStress = {'WaterTreshExpSurf':[], 'WaterTreshDevII':[] ,'WaterTreshDevI':[], 'WaterTreshFix':[],'WaterTreshRUE':[]}
    ls_NNIStress = {'NTreshRUE':[], 'NTreshExpSurf':[], 'NTreshDev':[], 'NTreshDevII':[]}
    ls_TStress = {'stressTRUE':[]}
    for i in range(nbplantes): ls_ftswStress['WaterTreshExpSurf'].append(1.);ls_ftswStress['WaterTreshDevII'].append(1.);ls_ftswStress['WaterTreshDevI'].append(1.);ls_ftswStress['WaterTreshFix'].append(1.);ls_ftswStress['WaterTreshRUE'].append(1.);ls_NNIStress['NTreshRUE'].append(1.);ls_NNIStress['NTreshExpSurf'].append(1.);ls_NNIStress['NTreshDev'].append(1.);ls_NNIStress['NTreshDevII'].append(1.);ls_TStress['stressTRUE'].append(1.);
    
    #6) Variables de profil plante (surface/eaclairement/N)
    
    LAIprofil, SurfprofilPlant = {}, []
    for i in range(0, na[2]):  LAIprofil[i]=0.#initialise variables globales de profils
    for i in range(nbplantes): SurfprofilPlant.append(deepcopy(LAIprofil))#liste de LAIprofil par plante
    
    deltaI_I0 = 0.05 #0.1 #delta entre classe d'aclairement relatif
    nbI_I0 = int(1./deltaI_I0) #nb classes d'eclairement relatif
    I_I0Classes = arange(deltaI_I0/2., 1.+deltaI_I0/2., deltaI_I0) #eclairememnt relatif moyen par classe
    I_I0profilLfPlant = [] #liste de surface de feuille par classe d'eclairement relatif
    for i in range(nbplantes): I_I0profilLfPlant.append(zeros(nbI_I0))
    I_I0profilPetPlant = deepcopy(I_I0profilLfPlant) #liste de longueur cumulee de petiole par classe d'eclairement relatif
    I_I0profilInPlant = deepcopy(I_I0profilLfPlant) #liste de longueur cumulee d'entre-noeuds par classe d'eclairement relatif
    
    NaClasses = ParamP[0]['Na0']*sh.Na_N0(I_I0Classes)#N0(INN=1.)*Na_N0(I_I0Classes)
    NlClasses = ParamP[0]['NL0Pet']*sh.Na_N0(I_I0Classes)
    NlinClasses = ParamP[0]['NL0Sh']*sh.Na_N0(I_I0Classes)
    # actuellement pas utilise -> serait a retirer proprement
    
    
    #variable de profil racine (a passer en dico?)
    res_root = [] 
    
    
    #RLProfil, RprospectProfil, rp0, rpp0 = [],[], {}, [] #liste de root length profil par horizon de sol; liste de profil des rayons de la racine primaire;rp0 et rpp0 sont les profils initiaux d'une plante, utilise pour faciliter l'instanciation de la liste de plantes
    #for i in range(0, ncouches_sol): rp0[i]=0.; rpp0.append(0.)
    #for i in range(nbplantes): RLProfil.append(deepcopy(rp0)); RprospectProfil.append(deepcopy(rpp0))
    
    
    return invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, ls_TStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root




def init_outputs(ParamP, nbplantes,ncouches_sol):
    
    # 1) OUTVAR
    #dico de sorties
    outvar = {'colnames':[],'pattern':[],'TT':[],'TTsol':[], 'SurfPlante':[], 'PARaPlante':[], 'PARiPlante':[], 'epsi':[], 'Hplante':[], 'Dplante':[],'dMSaer':[],'RLTot':[], 'RDepth':[], 'MS_aerien':[],'MS_feuil':[],'MS_tot':[], 'countSh':[], 'demandC':[], 'Leaf_Stem':[], 'NBsh':[], 'NBI':[],'time':[],'FTSW':[],'Etransp':[], 'DemandN_Feuil':[], 'DemandN_Pet':[], 'DemandN_Stem':[],'DemandN_Tot':[], 'Npc':[], 'NBD1':[], 'NBB':[], 'countShExp':[], 'NBBexp':[], 'R_DemandC_Root':[], 'SRL':[],'phmgPet':[],'phmgEntr':[],'phmgPet_m':[],'phmgEntr_m':[], 'Naerien':[], 'Npc_aer':[], 'DemandN_Tot_Aer':[], 'Nuptake_sol':[], 'NNI':[], 'Ndfa':[], 'Qfix':[],'dMSenFeuil':[], 'dMSenTige':[],'MS_pivot':[],'MS_rac_fine':[],'R_DemandC_Shoot':[],'RUE':[],'BilanC_PARa':[], 'BilanC_RUE':[],'BilanCdMStot':[], 'BilanCdMrac_fine':[], 'BilanCdMpivot':[], 'BilanCdMaer':[],'BilanCdMSenFeuil':[],'BilanCdMSenTige':[], 'DemCp':[],'remob':[],'Npc_piv':[], 'Npc_rac_fine':[], 'dRLenSentot':[], 'dMSenRoot':[], 'RLTotNet':[], 'MS_rac_fineNet':[],'perteN_rac_fine':[],'NBphyto':[], 'cutNB':[],'NBapexAct':[],'transpi':[], 'cumtranspi':[],'transpi':[], 'cumtranspi':[],'aliveB':[],'dMSmortGel':[],'dNmortGel':[],'TTphyllo':[],'dTT':[],'Udevstress':[],'Udev':[],'TTudev':[],'RUEpot':[]}
    outvar['pattern'].append(['pattern',0]+[surfsolref]*nbplantes)
    outvar['colnames'].append(['V1','steps']+riri.get_lsparami(ParamP, 'name')) #ajout des noms d'omglet en 1ere ligne
    
    # 2) Variables dynamique localisee du sol
    #id couches sorties sol (grand rhizotron)
    id_out = list(range(0,ncouches_sol))# tous les horizons verticaux#[0,1,4,11,17,25]# 5,10,25,60,90,130 cm, id de voxel dans le sol
    nomprof = ['5', '10', '15', '20', '25', '30','35', '40', '45', '50', '55', '60','65', '70', '75', '80', '85', '90','95', '100', '105', '110', '115', '120','125', '130','135', '140', '145', '150', '155', '160','165', '170', '175', '180', '185', '190','195', '200'] #a adapter selon dz_sol..
    out_HR = [['var','DOY']+nomprof[0:ncouches_sol]]#[['DOY','HP5', 'HP10', 'HP25', 'HP60', 'HP90', 'HP130']]
    
    
    return outvar, id_out, out_HR






def Start():
    
    #initialisation des variables globale de simulation
    global DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut,wasTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard, mn_sc, station
    
    ##seed nombre aleatoires
    global Rseed
    random.seed(Rseed)
    seed(Rseed)
    
    DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut,wasTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard, station = init_glob_variables_sim(meteo, mng, DOYdeb, deltalevmoy, deltalevsd)
    
    # initialisation des parametres plante
    global ParamP, nbplantes
    global ongletP, ongletPvois, optdamier, typearrangement,ongletScenar1,ongletScenar2, ls_pointes1
    #ongletP = 'Fix1'#'Fix'#'timbale'#'formica'#'canto'#'giga'##'alfalfa'#'geno_test'#'G3'#'C1'#'8_2'#'kayanne'#'leo'#'G1'#'timbale'##
    #ongletPvois = 'nonFix2'#'nonFix0'#'alfalfa'#'geno_test'#'G3'#
    #optdamier = 4
    #typearrangement='damier8'    
    ParamP, nbplantes = init_ParamP(path_plante, ongletP, ongletPvois, nbcote, type=typearrangement, opt=optdamier, ongletScenar1=ongletScenar1, ongletScenar2=ongletScenar2,idscenar1=idscenar1, idscenar2=idscenar2, mn_sc=mn_sc)
    
    #print 'Len ', riri.get_lsparami(ParamP, 'Len')
    #si graminee, trajectoire normalisee feuille L=1 - 1 par parametre plante
    ls_pointes1 = []
    for nump in range(nbplantes):
        pointes1 = []
        if int(ParamP[nump]['type'])==3:
            pointes, ls_ptsall , ls_cos, ls_sin = o3d.leg_grass_withoutgeom(1., 1., angfol=-5., nfol=ParamP[nump]['profilLeafI_nfol'][3], anginit=ParamP[nump]['gammaFeuil'])
            pointes1 = [array(pointes)]
        ls_pointes1.append(pointes1)
    
    
    #initialisation de la scene
    global carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr 
    
    carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr = init_scene(ParamP, inis, cote, nbcote, station,type=typearrangement)
    
    
    #initialisation du sol
    global S, Tsol, Uval, stateEV, b_,  obstarac_, ls_mat_res, setr, vCC
    S, Tsol, Uval, stateEV, b_ = init_sol(inis, meteo_j, par_sol, par_SN, Lsol, discret_solXY, dz_sol,  pattern8, opt_residu, obstarac_)
    vCC = init_plant_residues(S, opt_residu, ParamP)
    #mat_res = 0.*S.m_1 #en faire 
    ls_groupe_resid = list(map(int, riri.get_lsparami(ParamP, 'groupe_resid')))
    setr = list(set(ls_groupe_resid)) #set equivalent fonction r.unique!
    ls_mat_res = []
    for i in range(2):#len(setr)): #force a 2 sinon bug qd des esidu de l'esp 1 seulement
        ls_mat_res = ls_mat_res + [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#ajout de 4 residus par groupe d'organ et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)#  pour chaque groupe_resid 
    
    #print len(ls_mat_res) #= [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]
    #print(S.m_frac_evapZ)
    
    #initialisation des variables d'etat plante
    global invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress,ls_TStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root 
    
    invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, ls_TStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root = init_variables_plantes(ParamP, nbplantes)
    
    #initialisation des sorties
    global outvar, id_out, out_HR
    outvar, id_out, out_HR = init_outputs(ParamP, nbplantes, ncouches_sol)
    
    #initialisation des variables d'echange avec exterieur pour couplages sol/rayonnement
    global tag_inputs_soil_step, res_soil_step, tag_inputs_residue_updt, res_residue_step, tag_light_inputs, local_res_trans, local_res_abs_i, tag_light_inputs2, local_res_rfr
    
    ##seed nombre aleatoires
    #global Rseed
    #random.seed(Rseed)
    #seed(Rseed)
    #ajout des profils de taille potentiel par rang dans ParamP (calcule 1 seul fois) (cm) / parametres de morpho racine par ordre
    
    # pour gerer sortie visuelle en batch - Lucas
    #frameDisplay(True)





def StartEach():
    global TT,TTsol, STEPS_, STEPSsol_, isTTcut,wasTTcut, TT_repousse,  SurfprofilPlant, nbplantes, lsAxes, lsApex,lsApexAll, lsApexStop,lsOrgans, m_lais, res_trans, res_abs_i, res_rfr, m_lais_construct, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, invar, ls_systrac, Hcut, cutNB, epsilon #utilise dz, I0, k (global pas mis a jour)#Hmaxcouv, LAIvois, PARt,
    
    global tag_light_inputs, local_res_trans, local_res_abs_i, tag_light_inputs2, local_res_rfr, station    
    
    #calcul TT
    vT, vTsol = sh.Calc_Daily_vT(meteo_j, opt_optT) #daily temperature vector
    
    STEPS_ = sh.dTT(vT, [ParamP[0]['Tdev'], ParamP[0]['Tmin'], ParamP[0]['Tmax'], ParamP[0]['q']], optT=opt_optT) #prend valeur de nump=0 -> reference pour la simulation!
    TT = TT+STEPS_
    STEPSsol_ = sh.dTT(vTsol, [ParamP[0]['Tdev'], ParamP[0]['Tmin'], ParamP[0]['Tmax'], ParamP[0]['q']], optT=0)
    TTsol = TTsol + STEPSsol_
    
    #MAJ temps phyllochronique et udev
    invar['TTphyllo'] = array(invar['TTphyllo']) + array(invar['dTTphyllo'])
    graineC, graineN = sh.reserves_graine(invar, ParamP)
    for nump in range(nbplantes): 
        invar['dTT'][nump] = sh.dTT(vT, [ParamP[nump]['Tdev'], ParamP[nump]['Tmin'], ParamP[nump]['Tmax'], ParamP[nump]['q']], optT=opt_optT)
        invar['dTTsol'][nump] = sh.dTT(vTsol, [ParamP[nump]['Tdev'], ParamP[nump]['Tmin'], ParamP[nump]['Tmax'], ParamP[nump]['q']], optT=0)#forcement journalier
        
        if opt_PP == 1:
            stressPP = sh.linear_stress2(meteo_j['durjour'],[ParamP[nump]['PPtreshb'], ParamP[nump]['PPtreshh']], opt=0)
        else:
            stressPP = 1.
        #! gerer cas opt_ReadPP!
        
        stressW = ls_ftswStress['WaterTreshDevI'][nump]
        stressN = ls_NNIStress['NTreshDev'][nump]
        if opt_stressW == 0:
            stressW = 1.
        if opt_stressN == 0:
            stressN = 1.
        if opt_ReadstressN == 1.:
            stressN = mng_j['ForceNNI']#0.2
        if opt_ReadstressW == 1.:
            stressW = mng_j['ForceFTSW']#0.2
        
        invar['Udev'][nump] = invar['dTT'][nump] * stressPP #1. #effective thermal time taking PP ino account
        invar['Udevstress'][nump] = invar['Udev'][nump] * stressW * stressN #1. #udev shoots with water and N stresses
        invar['Udevsol'][nump] = invar['dTTsol'][nump] * stressPP
        
        ##update gel status par plante
        if (meteo_j['TmoyDay'] > ParamP[nump]['Tgel'] and opt_stressGel == 1) or  opt_stressGel == 0 or graineN[nump]>0.:
            invar['isGelDam'][nump] = 0
            invar['dMSmortGel'][nump] = 0.
            invar['dNmortGel'][nump] = 0.
            invar['countGelD'][nump] += 1 #count the number of days since last frost
        else:
            invar['isGelDam'][nump] = 1
            invar['countGelD'][nump] = 0
            #MSA = outvar['MS_aerien'][-1][nump+2]-epsilon #MSA cumulee de la coupe jusqu'au jour d'avant
            #invar['dMSmortGel'][nump] = MSA
            #invar['dNmortGel'][nump] = MSA*invar['Npc_aer'][nump]/100.
            print("GEL !!!!!!!!!!")
            
            #gerer le cas des gel pendant phase graine (-> mort?)
        
        if invar['germination'][nump]>0:
            invar['TT'][nump] = invar['TT'][nump] + invar['dTT'][nump]#juste effet Tair
            invar['TTsol'][nump] = invar['TTsol'][nump] + invar['Udevsol'][nump]#+ invar['dTTsol'][nump]
            invar['TTudev'][nump] = invar['TTudev'][nump] + invar['Udev'][nump]
    
    
    ############
    # step light transfer coupling
    ############
    
    #calcul profil surface couvert 
    
    mlaicot = sh.calc_surfcoty(invar['Mcoty'], invar['TT'], riri.get_lsparami(ParamP, 'DurGraine'), carto, ParamP, n_gamagroup, origin_grid, na, dxyz) #ajoute surface des cotyledons
    m_lais = deepcopy(m_lais_construct) + mlaicot
    
    
    #PAR / Blue voxel
    tag_light_inputs = [m_lais/surf_refVOX, triplets , ls_dif , meteo_j['I0']*surf_refVOX] #input tag
    #local_res_trans, local_res_abs_i = riri.calc_extinc_allray_multi(*tag_light_inputs, optsky='soc')#(m_lais/surf_refVOX, triplets , ls_dif , meteo_j['I0']*surf_refVOX, optsky='soc')
    local_res_trans, local_res_abs_i = riri.calc_extinc_allray_multi_reduced(*tag_light_inputs, optsky=station['optsky'], opt=station['sky'])
    res_trans, res_abs_i = local_res_trans, local_res_abs_i #mise a jour variables globales
    
    #R_FR voxel (calcul de zeta)
    tag_light_inputs2 = [res_trans/(meteo_j['I0']*surf_refVOX)] #input tag
    local_res_rfr = riri.rfr_calc_relatif(*tag_light_inputs2)#(res_trans/(meteo_j['I0']*surf_refVOX))
    res_rfr = local_res_rfr #mise a jour variables globales
    
    
    
    
    #remise a zero m_lais_construct et LAIprofilplant pour nouvelle iteration  
    m_lais_construct = zeros([n_gamagroup, na[2], na[1], na[0]])
    
    LAIp  = {}
    for i in range(0, len(list(SurfprofilPlant[0].keys()))): LAIp[i]=0.
    SurfprofilPlant = [] #liste de LAIprofil par plante
    for i in range(nbplantes): SurfprofilPlant.append(deepcopy(LAIp))
    I_I0profilLfPlant = []
    for i in range(nbplantes): I_I0profilLfPlant.append(zeros(nbI_I0))
    I_I0profilPetPlant = deepcopy(I_I0profilLfPlant)
    I_I0profilInPlant = deepcopy(I_I0profilLfPlant)
    
    #if TT%TTcutFreq <STEPS:
    if mng_j['Coupe']==1:
        Hcut = mng_j['Hcut']
        isTTcut = True
        wasTTcut = True
        isRegrowth = True
        cutNB += 1
        TT_repousse = TT
        invar['Maerien'] = [array([epsilon]*nbplantes)] #mise a epsilon - discutable: biomasse residuelle peut ne pas etre negligeable! trefle..
        invar['Mfeuil'] = [array([epsilon]*nbplantes)] #tout l'aerien
        invar['Naerien'] = invar['Maerien'][0]*invar['Npc_aer']/100. #remet avec teneur en N conservee par rapport a avant la coupe
        if opt_verbose==1:
            print(('cut ', Hcut))
        
        #invar['Naerien'] = []
        #for nump in range(nbplantes): 
        #    #invar['MS_aerien'][nump] = 1e-15 
        #    invar['Naerien'][nump] = 1e-15*invar['Npc_bis'][nump]/100. #remet avec teneur en N conservee par rapport a avant la coupe
    else:
        isTTcut = False
    
    
    #effet gel -> va pas ! ttes les plantes meurent pas (gerer plante a plante dans daily_loop)
    if sum(invar['isGelDam']) != 0 and opt_stressGel==1:
        #remet que derniere ligne des valeurs cumulee
        invar['Maerien'] = [invar['MS_aerien']]
        invar['Mfeuil'] = [invar['MS_feuil']]
        invar['dMSmortGel'] = [0.]*nbplantes
        invar['dNmortGel'] = [0.]*nbplantes
        for nump in range(nbplantes): 
            ##si gel status par plante et plus dans la phase de germination 
            if invar['isGelDam'][nump] == 1 :
                frac_mortGel = 0.95#1.#
                #mise a jour de ce qui est mort vers sorties sol
                invar['dMSmortGel'][nump] = frac_mortGel * invar['Maerien'][0][nump]
                invar['dNmortGel'][nump] = frac_mortGel * invar['Maerien'][0][nump]*invar['Npc_aer'][nump]/100.
                #mise a zero de ce qui est mort
                invar['Maerien'][0][nump] = (1.-frac_mortGel) * invar['Maerien'][0][nump] + epsilon #mise a epsilon - discutable: biomasse residuelle peut ne pas etre negligeable! trefle..
                invar['Mfeuil'][0][nump] = (1.-frac_mortGel) * invar['Maerien'][0][nump] + epsilon #tout l'aerien
                invar['Naerien'][nump] = (1.-frac_mortGel) * invar['Maerien'][0][nump]*invar['Npc_aer'][nump]/100.
                
                #ajout de residu gel - dans voxel du collet
                voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
                groupe_resid = int(ParamP[nump]['groupe_resid'])
                ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += invar['dMSmortGel'][nump]
                #tout mis en feuille/a ajuster
    
    
    #calcul offre/demandeC sur la base des tableaux precedent avant leur remise a zero
    tab = IOtable.conv_dataframe(IOtable.t_list(lsOrgans))
    OffCp = sh.calcOffreC (ParamP, tab, 'plt')#pas utilise??!
    #invar['DemCp'], invar['DemCp_lf'] , invar['DemCp_in'], invar['DemCp_pt'] = sh.calcDemandeC(ParamP, tab, 'plt',invar['dTT'], ls_ftswStress, ls_NNIStress)#attention, pour que calcul soit bon, faut le STEPS  suivant mis a jour!-> a faire en StartEach
    #print('DemCp',invar['DemCp'])
    
    if isTTcut == False and wasTTcut==False:
        invar['DemCp'], invar['DemCp_lf'] , invar['DemCp_in'], invar['DemCp_pt'] = sh.calcDemandeC(ParamP, tab, 'plt',invar['Udev'], ls_ftswStress, ls_NNIStress)#attention, pour que calcul soit bon, faut le STEPS  suivant mis a jour!-> a faire en StartEach
    else:
        invar['DemCp'], invar['DemCp_lf'] , invar['DemCp_in'], invar['DemCp_pt'] = {},{},{},{}
    #invar['L_Sp'] = sh.calcLeafStemRatio(ParmP,tab, lsAxes)
    #print('DemCp', invar['DemCp'], isTTcut , wasTTcut)
    
    if isTTcut == False and wasTTcut == True:
        wasTTcut = False #remet a faux un tour apres isTTcut
    
    #sortie    
    lsAxes = []
    lsApex = []
    lsApexStop = []
    lsApexAll = []
    lsOrgans =[['TT','organ','nump', 'nsh', 'rank', 'rankp', 'strate', 'surf', 'PARaF','statut','age','ordre','l','Long','DOY','cutNB', 'Larg']]
    ls_systrac = {}
    
    invar['lsAPrev'] = invar['lsA']
    invar['SurfPlante'], invar['PARaPlante'], invar['PARiPlante'], invar['NBD1'],invar['NBB'],invar['lsA'],invar['NBBexp'],invar['dMSenFeuil'] ,invar['dMSenTige'],invar['NBphyto'],invar['NBapexAct'],invar['dTTphyllo'] = [], [], [],[],[],[],[],[],[],[],[],[]
    for i in range(nbplantes): invar['SurfPlante'].append([]); invar['PARaPlante'].append([]); invar['PARiPlante'].append([]);invar['NBD1'].append(0) ; invar['NBB'].append(0);invar['NBBexp'].append(0);invar['lsA'].append([]);ls_systrac[i]=[]; invar['phmgPet'].append([1.]);invar['dMSenFeuil'].append(0.);invar['dMSenTige'].append(0.);invar['NBphyto'].append(0.);invar['NBapexAct'].append(0);invar['dTTphyllo'].append(0.);
    
    #ls_systrac[i]=[[carto[nump][0],carto[nump][1],0.,0.01,0.01]] #pour initialiser avec une racine et pas faire planter sol - pose pb seulement avant 1er step
    
    #initialisation des invar['PARiPlante'] avec ajout des PARi cotyledon:
    sh.calc_parapcoty(invar, m_lais, res_abs_i, invar['Mcoty'], invar['TT'], riri.get_lsparami(ParamP, 'DurGraine'), carto, ParamP, n_gamagroup, origin_grid, na, dxyz) 
    
    #sorties photomorphogenese
    for i in range(nbplantes): invar['phmgEntr'].append([1.]);invar['phmgPet_m'].append([1.]);invar['phmgEntr_m'].append([1.])
    
    invar_sc['ax']['StressHRac']={}
    invar_sc['ax']['PonderStressHRac']={}



def EndEach(lstring,lscene):
    
    
    global S, Uval, stateEV, DOY, meteo_j, mng_j, PP, res_root, nbplantes, surfsolref, ls_ftswStress, past_time, lsOrgans, ls_NNIStress, ls_TStress,ls_mat_res
    global lsApex, lsApexAll, ls_systrac, lims_sol, b_, opt_residu, vCC, carto, start_time, cutNB, I_I0profilInPlant, deltaI_I0, nbI_I0, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NlClasses, NaClasses, NlinClasses
    global ParamP, par_SN, invar, invar_sc, outvar, res_trans
    global tag_inputs_soil_step, res_soil_step, tag_inputs_residue_updt, res_residue_step
    
    
    #################
    #  daily loop 
    #################
    #tag variables to facilitate outside coupling and data exchange with third party application
    # * unpacks the list of arguments
    
    #Potential plant growth
    invar, outvar, ls_epsi, ls_demandeN_bis, temps = loop.daily_growth_loop(ParamP, invar, outvar, res_trans, meteo_j, mng_j, nbplantes, surfsolref, ls_ftswStress, ls_NNIStress, ls_TStress, lsApex, lsApexAll, opt_stressW, opt_stressN, opt_stressGel)
    #step soil 
    tag_inputs_soil_step = [S, par_SN, lims_sol, surfsolref, stateEV, Uval, b_, meteo_j,  mng_j, ParamP, invar, ls_epsi, ls_systrac, ls_demandeN_bis, opt_residu] #input tag
    res_soil_step = loop.step_bilanWN_sol(*tag_inputs_soil_step)
    S, stateEV, ls_ftsw, ls_transp, ls_Act_Nuptake_plt, temps_sol = res_soil_step #unpacks results from a list and updates global variables
    #update stress variables
    invar, invar_sc, outvar, I_I0profilInPlant, ls_ftswStress, ls_NNIStress, ls_TStress = loop.Update_stress_loop(ParamP, invar, invar_sc, temps, DOY, nbplantes, surfsolref, ls_epsi, ls_ftsw, ls_transp, ls_Act_Nuptake_plt, ls_demandeN_bis, ls_ftswStress, ls_TStress, lsOrgans, lsApex, start_time, cutNB, deltaI_I0, nbI_I0, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NlClasses, NaClasses, NlinClasses, outvar)  
    #update soil residues
    tag_inputs_residue_updt = [ls_mat_res, vCC, S, carto, lims_sol, ParamP, invar, opt_residu] #input tag
    res_residue_step = loop.update_residue_mat(*tag_inputs_residue_updt)
    ls_mat_res, S = res_residue_step #unpacks results from a list and updates global variables
    
    #pourquoi ls_res_mat remis a zero juste apres????
    
    
    
    #################
    # fin des mises a jour variables (meteo...) pour step suivant
    #################
    
    DOY+=1
    meteo_j = IOxls.extract_dataframe(meteo, ['TmoyDay','RG','Et0','Precip','Tmin','Tmax','Tsol'], 'DOY', val=DOY)
    meteo_j['I0'] = [0.48*meteo_j['RG'][0]*10000/(3600*24)]#flux PAR journalier moyen en W.m-2 / RG en j.cm-2
    mng_j = IOxls.extract_dataframe(mng, ['Coupe','Irrig', 'FertNO3','FertNH4','Hcut'], 'DOY', val=DOY)
    if opt_verbose==1:
        print (DOY)
    
    for k in list(meteo_j.keys()): meteo_j[k]=meteo_j[k][0]
    for k in list(mng_j.keys()): mng_j[k]=mng_j[k][0]
    meteo_j['durjour'] = sh.DayLength (station['latitude'],sh.DecliSun (DOY % 365))
    mng_j['ForceNNI'] = 1.#0.2 #to force NNI value (could read in management file)
    
    #print invar['rgeq']
    
    #archivage de lsOrgans
    savelsOrgans.append(lsOrgans)
    
    
    #mise a jour HR sol (fichier profil)
    if outf['outHRfile'] != 0.:
        matr = S.HRp()#
        out_HR.append(['HRp', DOY]+mean(matr, axis=1)[id_out,0].tolist())
    
    if outf['outFTSWfile'] != 0.:
        matr = S.ftsw_t #S.HRp()#
        out_HR.append(['FTSW',DOY]+mean(matr, axis=1)[id_out,0].tolist())
    
    if outf['outNO3file'] != 0.:
        matr = S.m_NO3 #S.HRp()#
        out_HR.append(['m_NO3',DOY]+sum(matr, axis=1)[id_out,0].tolist())#somme!
    
    if outf['outNH4file'] != 0.:
        matr = S.m_NH4 #S.HRp()#
        out_HR.append(['m_NN4',DOY]+sum(matr, axis=1)[id_out,0].tolist())#somme!
    
    #print invar['germination'], invar['TT']
    #print invar_sc['sh']['Surf'], lsSurfSh
    #print invar['NBBexp'][nump], outvar['NBBexp'][-1][0][nump+2]
    #print invar['lsA']
    #print sum(I_I0profilLfPlant[0]*NaClasses), sum(I_I0profilLfPlant[0]), sum(I_I0profilLfPlant[0]*NaClasses)/sum(I_I0profilLfPlant[0])
    #print sum(I_I0profilPetPlant[0])
    
    #prints et log
    #print epsi, sum3(S.asw_t)  #epsi, map_PI, D,  sum3(ls_roots_eff[0]), sum3(m_frac_evap),sum3(m_frac_transpi),sum3(m_frac_evap)+sum3(m_frac_transpi), sum3(S.asw_t)#, S1#, #, ls_transp, ftsw_tevapo_tot#ftsw_t#
    #print invar_sc['ax']['MaxPARaF']
    #print 'mat_res', map(sum, ls_mat_res)
    #remise a zero de ls_mat_res
    #ls_mat_res = [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#par groupe d'organe et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)# + faire pour chaque groupe_resid (1 seul ici)
    ls_mat_res = []
    for i in range(2):#len(setr)): #force a 2 sinon bug qd des residus de l'esp 1 seulement
        ls_mat_res = ls_mat_res + [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#ajout de 4 residus par groupe d'organ et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)#  pour chaque groupe_resid 
    
    #print(amin(S.m_NO3),amin(S.m_NH4))
    
    #def PostDraw():#lstring,lscene):
    #################
    # pour gerer les vues pour 1 film - lucas (movDisplay == 1)
    #################
    #global DOY, path_out
    
    
    outimagepathtemp = os.path.join(path_out, 'scene_'+str(DOY)+'.bmp')#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
    if movDisplay == 1:
        ## fait pour simul depuis L-py reglee manuellement
        #frameDisplay(True)
        #Viewer.display(lscene)
        #Viewer.grids.setXYPlane(0)
        #Viewer.camera.setPosition((0,-150,20))
        #Viewer.camera.lookAt((0,-150,20),(20,20,-20))#((15,100,100),(0,0,0))
        Viewer.frameGL.setSize(600,500)
        Viewer.frameGL.saveImage(outimagepathtemp)
        #Viewer.stop()



def End(lstring,lscene):
    global res_root, outvarpath,outimagepath, savelsOrgans, lsOrgans
    
    ls_fileOUT = [] #liste des fichiers ecrits en sortie
    #fermeture des bilans -> print cause pb: les sortir en fichier!
    #sys.stdout=open(outBilansTxt,'w')
    S.CloseWbalance(print_=0)
    S.CloseNbalance(print_=0)
    S.CloseCbalance(print_=0)
    #sys.stdout.close() #!! -> fait planter les print en re-run
    #en faire une fonction +  ecriture des disctionnaires en Rdata?  
    
    
    dicout= {}
    dicout['NRain'] = S.bilanN['cumRain']
    dicout['NIrrig'] = S.bilanN['cumIrrig']
    dicout['fertNO3'] = S.bilanN['cumfertNO3']
    dicout['fertNH4'] = S.bilanN['cumfertNH4']
    dicout['HumusNMin'] = S.bilanN['cumMinN']
    if opt_residu == 1:
        dicout['Res1'] = S.bilanN['cumNRes1']
        dicout['Res2'] = S.bilanN['cumNRes2']
        dicout['Res3'] = S.bilanN['cumNRes3']
        dicout['ResidueMinN'] = S.bilanN['cumNRes1']+S.bilanN['cumNRes2']+S.bilanN['cumNRes3']
        for i in range(len(S.bilanN['NminfromNres'])):
            dicout['NminfromNres'+str(i)] = S.bilanN['NminfromNres'][i] #ajout des sorties Nmin par residu
    
    dicout['Lix'] = S.bilanN['cumLix']
    #dicout['N2O'] = S.bilanN['cumN2O']
    dicout['UptPlt'] = list(map(sum, S.bilanN['cumUptakePlt'])) 
    dicout['azomes'] = S.bilanN['azomes']
    #serait a formater dans module sol
    
    #y ajoute les elements du bilan de C plante - mais devrait sortir un fichier separe!
    dicout['PARa'] = outvar['BilanC_PARa']
    dicout['RUE'] = outvar['BilanC_RUE']
    dicout['dMStot'] = outvar['BilanCdMStot']
    dicout['dMSrac'] = outvar['BilanCdMrac_fine']
    dicout['dMSpiv'] = outvar['BilanCdMpivot']
    dicout['dMSaer'] = outvar['BilanCdMaer']
    dicout['dMSenFeuil'] = outvar['BilanCdMSenFeuil']
    dicout['dMSenTige'] = outvar['BilanCdMSenTige']
    #WB
    dicout['cumEV'] = S.bilanW['cumEV']
    dicout['cumTransp'] = S.bilanW['cumTransp']
    dicout['cumD'] = S.bilanW['cumD']
    
    
    if outf['outBilanNfile'] != 0.:
        IOtable.write_dict(dicout, path_out, outBilanNfile)
        ls_fileOUT.append(os.path.join(path_out, outBilanNfile))
    
    
    #ecriture en sortie du profil racinaire
    if outf['resrootfile'] != 0.:
        resrootpath = os.path.join(path_out, resrootfile)#r'H:\devel\grassland\newres.csv'
        f = open(resrootpath, 'w')#file (resrootpath, 'w')#r'H:\devel\grassland\newres.csv'
        IOtable.ecriture_csv(res_root, f)
        f.close()
        ls_fileOUT.append(resrootpath)
    
    if outf['lsorgfile'] != 0.:
        lsorgpath = os.path.join(path_out, lsorgfile)#r'H:\devel\grassland\grassland\L-gume\lsAxes.csv'
        f = open(lsorgpath, 'w')#file (lsorgpath, 'w')
        IOtable.ecriture_csv_fromlist(savelsOrgans,  f)#savelsOrgans=liste des lsOrgans pour chaque iteration #lsOrgans #lsAxes #lsApex #lsApexStop #ls_systrac[0] 
        f.close()
        ls_fileOUT.append(lsorgpath)
    
    if outf['outsdfile'] != 0. and opt_sd==1:# valeur de parametres par plante 
        #ls_parname = ['name']+['Len'] # a recuperer=la bonne liste
        sd_fichier_g4=pd.read_excel(path_variance_geno, sheet_name=ongletP)
        ls_parname = ['name']+list(sd_fichier_g4.columns) [1:] #liste les noms de colonne a  partir de la deuxieme; suppose la meme pour les 2 sp
        nbp = len(riri.get_lsparami(ParamP, 'name'))
        res_sd = {'nump':range(0,nbp)}
        res_sd['retard'] = test_retard[0:nbp]
        for p in ls_parname:
            res_sd[p] = riri.get_lsparami(ParamP, p)
        
        #ajout des coord x,y des plantes
        xcarto, ycarto = [],[]
        for i in range(len(carto)):
            xcarto.append(carto[i][0]); ycarto.append(carto[i][1])
        
        res_sd['x'] = xcarto
        res_sd['y'] = ycarto
        
        IOtable.write_dict(res_sd, path_out, outsdfile)
        ls_fileOUT.append(os.path.join(path_out, outsdfile))
    
    if outf['outvarfile'] != 0.:
        outvarpath = os.path.join(path_out, outvarfile)#r'H:\devel\grassland\grassland\L-gume\toto.csv'
        ls_keyvar_pot = ['colnames','pattern','TT','time','cutNB','SurfPlante', 'PARaPlante', 'PARiPlante', 'epsi', 'dMSaer', 'Hplante', 'Dplante','RLTot','RDepth','MS_aerien','MS_feuil','MS_tot','countSh','countShExp','demandC','Leaf_Stem','NBsh','NBI','NBD1','NBB','FTSW','Etransp','DemandN_Feuil','DemandN_Pet', 'DemandN_Stem','DemandN_Tot', 'DemandN_Tot_Aer', 'Npc', 'Npc_aer', 'NNI','Ndfa', 'Qfix','Naerien','Nuptake_sol','R_DemandC_Root', 'SRL','dMSenFeuil','dMSenTige', 'MS_pivot', 'MS_rac_fine','R_DemandC_Shoot','RUEpot','RUE','Npc_piv','Npc_rac_fine','dRLenSentot','dMSenRoot','RLTotNet','MS_rac_fineNet','perteN_rac_fine','NBphyto','NBapexAct','transpi','cumtranspi','aliveB','dMSmortGel','dNmortGel','TTphyllo','DemCp','dTT','Udev','Udevstress','TTudev']#,"phmgEntr","phmgEntr_m","phmgPet","phmgPet_m"]
        #valide cles active via fichier d'entree
        ls_keyvar = ['colnames']
        for i in range(1, len(ls_keyvar_pot)):
            k = ls_keyvar_pot[i]
            if outfvar[k] !=0.:
                ls_keyvar.append(k)
        
        #ecrit fichier avec variables selectionnees
        IOtable.write_dicttables(outvarpath, outvar, ls_keyvar)
        ls_fileOUT.append(outvarpath)
    
    if outf['outHRfile'] != 0. or outf['outFTSWfile'] != 0. or outf['outNO3file'] != 0. or outf['outNH4file'] != 0.:
        outHRpath = os.path.join(path_out, outHRfile)#r'H:\devel\grassland\grassland\L-gume\outHR.csv'
        f = open(outHRpath, 'w')#file (outHRpath, 'w')
        IOtable.ecriture_csv(out_HR, f)#ls_systrac[0]
        f.close()
        ls_fileOUT.append(outHRpath)
    
    ##############!!!!!!!!!!!!
    if outf['outMngfile'] != 0.:
        IOtable.write_dict(mng, path_out, outMngfile)
        ls_fileOUT.append(os.path.join(path_out, outMngfile))
    
    #pour gerer la vue de la sortie finale - lucas
    outimagepath = os.path.join(path_out, outimagefile)#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
    if frDisplay == 1:
        frameDisplay(True)
        Viewer.display(lscene)
        Viewer.grids.setXYPlane(0)
        Viewer.camera.setPosition((0,-150,20))
        Viewer.camera.lookAt((20,20,50),(20,20,50))#((0,-150,20),(20,20,-20))#((15,100,100),(0,0,0)) #((xPos,yPos,zPos),(xDir,yDir,zDir)), si Pos=Dir -> vu du dessus, modifier z pour zoomer/dezoomer
        Viewer.frameGL.setSize(850,850)
        Viewer.frameGL.saveImage(outimagepath)
        Viewer.stop()
    
    #frameDisplay(True)
    #Viewer.display(lscene)
    #Viewer.frameGL.saveImage(outimagepath)
    
    
    #IOtable.write_dict(invar_sc['ax']['PARaF'], r'H:\devel\grassland\grassland\L-gume', 'tot.csv')
    #print sum(m_lais), map(sum, invar['SurfPlante']) ->OK meme surface
    #print sh.cumul_lenIN(lsApex, IOtable.conv_dataframe(IOtable.t_list(lsOrgans)), I_I0profilInPlant)#lsApex
    #tab = IOtable.conv_dataframe(IOtable.t_list(lsOrgans))
    #print calcSurfScale(tab, 'sh')
    
    #zippe les sorties si option opt_zip
    if opt_zip==1:
        if opt_verbose == 1:
            print(ls_fileOUT)
        
        nomzip = outvarfile[0:-4]
        IOtable.Outzip(path_out, nomzip+'.zip', ls_fileOUT)
        IOtable.Outdel(ls_fileOUT)
    
    pass




module Sd(nump) # Seed
module A(nump, nsh, statut, age, duromb, rank, rgeq, phyllotax) #primary shoot Apex (rgeq: ajoute pour grass tenir compte effet tallage/coupe)
module A2(nump, nsh, statut, age, duromb, rank, rankp, phyllotax) #secondary shoot Apex (rankp= rang sur porteur)
module D(nump, nsh, statut, age, posi, parent) #Dormant bud of the crown
module D2(nump, nsh, age, rankp, phyllotax,shoottype) #dormant bud at the leaf axil
module B(nump, nsh, age, posi, nrhiz, azi, par, statut) #active Bud of the crown nsh=numero de tige; rhiz  nb noeud de rhizome
module SHP(nump, nsh, azi, elv0, posi, nbp,par) #SHoot Parameters: nbp et par pour moduler incli_ini en fonction de longueur et lumiere
module In(nump, nsh, age, rank, rankp, l, statut, ordre) #Internode (l longueur normalisee)
module Lf(nump, nsh, age, azi, rank, rankp, l, tt_omb,Lcut, statut, ordre) #Leaf (l longueur normalisee)
module Pet(nump, nsh, age, azi, l, statut) #Petiole
module Stp(nump, azi, l, statut)#Stipule
module RA(nump, nsh, age, rankp, agecum, moduloH) #primary Root Apex
module RB(nump, nsh, age, rankp, statut) #adventive root bud
module RS(nump, nsh, rankp, moduloH) #Root Segment
module RLB(nump, nsh, age, rankp, Horiz) #Root Lateral Bud
module RLAP(nump, nsh,age,rankp,l, Horiz) #Root Lateral Apex Prospection (max diameter reached by secondary roots)
module Coll(posi) #Collar 

module sol(S, nbcol) #objet sol entier (nbcol en y)
module solxy(S, idcol) #colone de sol pour visu 2D
module attente(n) #pour attendre initialisation des variables avant de representer le sol
module pattern(pos) #pour sol surface


Axiom: [attente(1)][Sd(0)][Sd(1)][Sd(2)][Sd(3)][Sd(4)][Sd(5)][Sd(6)][Sd(7)][Sd(8)][Sd(9)][Sd(10)][Sd(11)][Sd(12)][Sd(13)][Sd(14)][Sd(15)][Sd(16)][Sd(17)][Sd(18)][Sd(19)][Sd(20)][Sd(21)][Sd(22)][Sd(23)][Sd(24)][Sd(25)][Sd(26)][Sd(27)][Sd(28)][Sd(29)][Sd(30)][Sd(31)][Sd(32)][Sd(33)][Sd(34)][Sd(35)][Sd(36)][Sd(37)][Sd(38)][Sd(39)][Sd(40)][Sd(41)][Sd(42)][Sd(43)][Sd(44)][Sd(45)][Sd(46)][Sd(47)][Sd(48)][Sd(49)][Sd(50)][Sd(51)][Sd(52)][Sd(53)][Sd(54)][Sd(55)][Sd(56)][Sd(57)][Sd(58)][Sd(59)][Sd(60)][Sd(61)][Sd(62)][Sd(63)]#[Sd(64)][Sd(65)][Sd(66)][Sd(67)][Sd(68)][Sd(69)][Sd(70)][Sd(71)][Sd(72)][Sd(73)][Sd(74)][Sd(75)][Sd(76)][Sd(77)][Sd(78)][Sd(79)][Sd(80)][Sd(81)][Sd(82)][Sd(83)][Sd(84)][Sd(85)][Sd(86)][Sd(87)][Sd(88)][Sd(89)][Sd(90)][Sd(91)][Sd(92)][Sd(93)][Sd(94)][Sd(95)][Sd(96)][Sd(97)][Sd(98)][Sd(99)][Sd(100)][Sd(101)][Sd(102)][Sd(103)][Sd(104)][Sd(105)][Sd(106)][Sd(107)][Sd(108)][Sd(109)][Sd(110)][Sd(111)][Sd(112)][Sd(113)][Sd(114)][Sd(115)][Sd(116)][Sd(117)][Sd(118)][Sd(119)][Sd(120)][Sd(121)][Sd(122)][Sd(123)][Sd(124)][Sd(125)][Sd(126)][Sd(127)][Sd(128)][Sd(129)][Sd(130)][Sd(131)][Sd(132)][Sd(133)][Sd(134)][Sd(135)][Sd(136)][Sd(137)][Sd(138)][Sd(139)][Sd(140)][Sd(141)][Sd(142)][Sd(143)]#[Sd(144)][Sd(145)][Sd(146)][Sd(147)][Sd(148)][Sd(149)][Sd(150)][Sd(151)][Sd(152)][Sd(153)][Sd(154)][Sd(155)][Sd(156)][Sd(157)][Sd(158)][Sd(159)][Sd(160)][Sd(161)][Sd(162)][Sd(163)][Sd(164)][Sd(165)][Sd(166)][Sd(167)][Sd(168)][Sd(169)][Sd(170)][Sd(171)][Sd(172)][Sd(173)][Sd(174)][Sd(175)][Sd(176)][Sd(177)][Sd(178)][Sd(179)][Sd(180)][Sd(181)][Sd(182)][Sd(183)][Sd(184)][Sd(185)][Sd(186)][Sd(187)][Sd(188)][Sd(189)][Sd(190)][Sd(191)][Sd(192)][Sd(193)][Sd(194)][Sd(195)][Sd(196)][Sd(197)][Sd(198)][Sd(199)][Sd(200)][Sd(201)][Sd(202)][Sd(203)][Sd(204)][Sd(205)][Sd(206)][Sd(207)][Sd(208)][Sd(209)][Sd(210)][Sd(211)][Sd(212)][Sd(213)][Sd(214)][Sd(215)][Sd(216)][Sd(217)][Sd(218)][Sd(219)][Sd(220)][Sd(221)][Sd(222)][Sd(223)][Sd(224)][Sd(225)][Sd(226)][Sd(227)][Sd(228)][Sd(229)][Sd(230)][Sd(231)][Sd(232)][Sd(233)][Sd(234)][Sd(235)][Sd(236)][Sd(237)][Sd(238)][Sd(239)][Sd(240)][Sd(241)][Sd(242)][Sd(243)][Sd(244)][Sd(245)][Sd(246)][Sd(247)][Sd(248)][Sd(249)][Sd(250)][Sd(251)][Sd(252)][Sd(253)][Sd(254)][Sd(255)]

#Axiom: [pattern(0)sol(S)]plantation(nbplantes-1)


derivation length: DOYend-DOYdeb#200#98#224#73#93#66#93#66#149#119#179#300#365#(jours)
production:

#plantation(nbplt):
#    if nbplt>=0:
#    #for i in range(0, nbplt):
#        nproduce [Sd(nbplt)]plantation(nbplt-1)
#    else:
#        produce *


Sd(nump) :
    produce: Coll(carto[nump])RA(nump,0,-1,0,0,0)][SetHead()/(random.uniform(0.,360.))&(90)B(nump,0,ParamP[nump]['phyllochron'],carto[nump],0,random.uniform(0.,360.),0,'exp')] #ouverture de [ racine dans le Coll

B(nump, nsh, age, posi, nrhiz, azi, par, statut):
    global ls_ftswStress
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    invar['NBB'][nump]+=1
    invar['lsA'][nump].append(nsh)
    if statut=='exp':
        invar['NBBexp'][nump]+=1
    
    vox = riri.WhichVoxel(carto[nump], origin_grid, na, dxyz)
    newpar = res_trans[-1][vox[1]][vox[0]]/surf_refVOX # A ameliorer :pris sur carto et position reelle des bourgeosn-> pb pour stolons?
    nbExp_Prev = outvar['NBBexp'][-1][0][nump+2]+1
    
    # phyllo pot change selon rgeq pour les graminees
    if int(ParamP[nump]['type'])==3 : #graminee
        phylloPot = sh.PhylloPot_Grass(1, phylloI=ParamP[nump]['phyllochron'], k=0.3)#ParamP[nump]['phyllochron']#
    else: 
        phylloPot = ParamP[nump]['phyllochron']
    
    
    #control de la vitesse de tallage
    if nsh==0:#tige seminale -> pas d'attente
        deldeb = 0
        retard = test_retard[nump]
    else:
        retard = 0
        if nsh==1 and ParamP[nump]['nshoots']>1.:#pousse initiale -> debut tallage
            deldeb= ParamP[nump]['debTallage'] * phylloPot
        #else:
        #    deldeb =  ParamP[nump]['phyllochron'] / ParamP[nump]['RvitTallage']
        elif statut=='exp':#bourgeon actifs produits sans dormance (tallage)
            deldeb =  phylloPot * ParamP[nump]['RvitTallage']
        else: #bourgeons 'regular'
            deldeb = 0.
    
    #print 'B', nsh, age, deldeb
    
    
    stressW = ls_ftswStress['WaterTreshDevI'][nump]
    stressN = ls_NNIStress['NTreshDevII'][nump]
    if opt_stressW == 0:
        stressW = 1.
    if opt_stressN == 0:
        stressN = 1.
    if opt_ReadstressN == 1.:
        stressN = mng_j['ForceNNI']#0.2
    if opt_ReadstressW == 1.:
        stressW = mng_j['ForceFTSW']#0.2
    
    remiseNIcoupe = 3#2# max de stade bourgeon
    remiseNIgel = 5# max apres un gel
    
    if age >= deldeb/(0.00001+stressW*stressN) and newpar>=meteo_j['I0']*ParamP[nump]['par_tresh_til'] and nrhiz==0: #effet par_tresh marche mais a l'envers??? ->OK
        ##azi = random.uniform(0,360)
        elv0 = random.uniform(ParamP[nump]['elv0b'],ParamP[nump]['elv0h'])#(0,90)
        ageref = min(phylloPot, phylloPot*ParamP[nump]['RvitTallage'])
        newageB = age%ageref - retard#- test_retard[nump]#age%ParamP[nump]['phyllochron'] - test_retard[nump] 
        newageA = age%ageref +STEPS - retard#- test_retard[nump]#age%ParamP[nump]['phyllochron']+STEPS - test_retard[nump] 
        
        #stade bourgeon
        if invar['countGelD'][nump]>4:
            deltaBud = min(remiseNIcoupe, int(age/phylloPot))#plafonne a 2 phylloc pour B ages
        else: #apres gel
            deltaBud = remiseNIgel
        
        #position ini
        if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2 : #legume or non fixing-legume
            #boureons sur le collet -> epend de rpiv
            rpiv = invar['DiampivMax'][nump]/2.+ (invar['countShExp'][nump]/ParamP[nump]['nshoots'])*ParamP[nump]['offset_diamP']#0.5 #offset_diam atteint pour nbshoot max
            posini = array(carto[nump]) + array([random.uniform(-rpiv,rpiv),random.uniform(-rpiv,rpiv),0.])
        elif int(ParamP[nump]['type'])==3: #graminee
            rplt = (invar['countShExp'][nump]*0.0002/4)**0.5 + ParamP[nump]['offset_diamP']#5. #diamete base qui depend du nb de talle (densite de 6000 talle/m2
            posini = array(carto[nump]) + array([random.uniform(-rplt,rplt),random.uniform(-rplt,rplt),0.])
        
        new_nrhiz = binomial(ParamP[nump]['DistLRhizn'], ParamP[nump]['DistLRhizp'])#2#5#0
        
        
        if statut=='exp' and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1:#nsh< ParamP[nump]['nshoots'] and  : #modifie en nshoots-1, sinon la premiere tige n'est pas comptee!
            #print nump, 'B', newageA, test_retard[nump]
            newazi = random.uniform(0.,360.)
            invar['countSh'][nump] += 1
            newnsh = invar['countSh'][nump] #nsh+1
            invar['countShExp'][nump] += 1            
            invar['countSh'][nump] += 1
            newnsh2 = invar['countSh'][nump] #nsh+1
            
            if nsh==0 and invar['germination'][nump] == 0: #tige seminale, production du premier apex
                invar['germination'][nump] = 1
                sh.germinate(invar, ParamP[nump], nump)
            
            rgeq = invar['rgeq'][nump]#0
            #print nsh, 'rgeq', rgeq, invar['rgeq'][nump]
            produce [@M(posi[0],posi[1],posi[2])SetHead()/(azi)&(90)B(nump,newnsh,newageB,posini,new_nrhiz,newazi,0,'exp')][D(nump,newnsh2,0,newageB,posini,nsh)]SHP(nump,nsh, azi,elv0,posi,0,newpar)GetPos(0,0,0,nump)A(nump,nsh,1,newageA,0,0,rgeq,azi)
        else:
            invar['countSh'][nump] += 1
            newnsh = invar['countSh'][nump] #nsh
            
            if nsh==0 and invar['germination'][nump] == 0: #tige seminale, production du premier apex
                invar['germination'][nump] = 1
                sh.germinate(invar, ParamP[nump], nump)
            
            rgeq = invar['rgeq'][nump]#0
            produce [D(nump,newnsh,0,newageB,posini,nsh)]SHP(nump,nsh, azi,elv0,posi,0,newpar)GetPos(0,0,0,nump)A(nump,nsh,1,newageA,0,deltaBud, rgeq,azi)
    elif age >= phylloPot/(0.00001+ls_ftswStress['WaterTreshDevI'][nump]*ls_NNIStress['NTreshDevII'][nump]) and nrhiz>=1:
        newageB = age%phylloPot
        produce F(ParamP[nump]['LenRhiz'])B(nump,nsh,newageB, posi,  nrhiz-1, azi, newpar, statut)
    else:
        newageB = age+STEPS
        produce B(nump,nsh,newageB, posi, nrhiz, azi, newpar, statut)



GetPos(X0,Y0,Z0,nump2)A(nump,nsh,statut, age, duromb, rank, rgeq, phyllotax):
    global ls_ftswStress, lsAxes, lsApex, lsApexStop, lsApexAll#, Hplante, Dplante
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    idsh = str(nump)+'_'+str(nsh)
    idax = str(nump)+'_'+str(nsh)+'_'+str(0)
    
    invar['lsA'][nump].append(nsh)
    
    if Z0>invar['Hplante'][nump]:
        invar['Hplante'][nump] = Z0
    if Z0>Hcut and isTTcut==True:
        invar['Hplante'][nump]=Hcut
        invar['Dplante'][nump]=0.
        invar['lsA'][nump].remove(nsh)
    if isTTcut==True and int(ParamP[nump]['type'])==3: #cas des graminees
        invar['Hplante'][nump]=Hcut
    if invar['isGelDam'][nump] == 1:#coupe gel
        invar['Hplante'][nump]=0.001
        invar['Dplante'][nump]=0.
        invar['lsA'][nump].remove(nsh)
        #invar['lsApexMort'][nump].append(nsh) #si mis, retire aussi les D()
        IOxls.append_dic(invar_sc['sh']['MaxNI'], idsh, rank+10)#+10 pour pas repartir avec gros retard!
        produce *
    
    dX, dY = X0-carto[nump][0],Y0-carto[nump][1]
    dist2 =  dX*dX+dY*dY
    if dist2 > invar['Dplante'][nump]**2:
        invar['Dplante'][nump] = sqrt(dist2)
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARup = meteo_j['I0'] if vox[2] == 1 else res_trans[vox[2]-1][vox[1]][vox[0]] / surf_refVOX
    PARdown = res_trans[vox[2]][vox[1]][vox[0]] / surf_refVOX
    PARapex = PARup - (PARup-PARdown)*(Z0%dxyz[2]) / dxyz[2] #interpolation lineaire a l'iterieur du voxel
    I_I0 = PARapex/meteo_j['I0']
    
    ##invar_sc['ax']['MaxPARaF']
    
    try:
        PARlf = invar_sc['ax']['MaxPARaF'][idax]
    except:
        PARlf = 0.
    
    #print 'A', nsh, rank, rgeq, PARapex, PARlf, statut
    PARsense = max(PARapex, PARlf) #niveau percu = mas d'apex ou feuille
    
    
    stressW = ls_ftswStress['WaterTreshDevI'][nump]
    stressN = ls_NNIStress['NTreshDev'][nump]
    if opt_stressW == 0:
        stressW = 1.
    if opt_stressN == 0:
        stressN = 1.
    if opt_ReadstressN == 1.:
        stressN = mng_j['ForceNNI']#0.2
    if opt_ReadstressW == 1.:
        stressW = mng_j['ForceFTSW']#0.2
    
    # phyllo pot change selon rgeq pour les graminees
    if int(ParamP[nump]['type'])==3 : #graminee
        rk = rank+rgeq
        phylloPot = sh.PhylloPot_Grass(rk, phylloI=ParamP[nump]['phyllochron'], k=0.3)#ParamP[nump]['phyllochron']#
    else: 
        phylloPot = ParamP[nump]['phyllochron']
    
    #print(nsh, rank, rgeq, phylloPot)
    
    #mise a jour du temps phyllochronique
    dTTphyllo = invar['Udev'][nump]*stressW*stressN/phylloPot #invar['dTT'][nump]*stressW*stressN/phylloPot #deta temps phyllochronique
    if dTTphyllo > invar['dTTphyllo'][nump] and PARsense>=meteo_j['I0']*ParamP[nump]['par_tresh']:
        invar['dTTphyllo'][nump] = dTTphyllo
    
    #print nump, age #malgre retard, tous les A ont le meme age
    if age >= phylloPot/(0.00001+stressW*stressN): # introduit arret developpement des apex en fonction gradient vertical PAR
        if PARsense>=meteo_j['I0']*ParamP[nump]['par_tresh']:
            #inititalisation plante (TT de la firstleaf et stage germination)
            if nsh==0:
                invar['firstleaf'][nump]=min(TT,invar['firstleaf'][nump])
                if rank>=1: #tige seminale, production de la premiere feuille
                    invar['germination'][nump] = 2
            
            newage = age%phylloPot+STEPS
            #calcul du rankp des organes (feuille/petiole/gaine)
            if int(ParamP[nump]['type'])==3:
                newagef = STEPS
            else :
                newagef = newage
            
            liniF = sh.expansion(newagef, ParamP[nump]['aF'], ParamP[nump]['delaiF'])*stressW*stressN
            liniP =  sh.expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP'])#*stressW*stressN# for grasses
            liniS = sh.expansion(newage, ParamP[nump]['aS'], ParamP[nump]['delaiS'])*stressW*stressN
            liniE = sh.expansion(newage, ParamP[nump]['aE'], ParamP[nump]['delaiE'])*stressW*stressN#ajout lucas: necessaire chez le TB! sinon, les entrenoeuds demarrent au milieu de leur croissance... Pour eviter ce genre de problemes et/ou des decalages bizarres, s'assurer a l'avenir que les delaiE, delaiF et delaiP soient normalises pour que le TT au point d'inflexion de la fct logistique soit a la moitie d'un phyllochrone.
            
            lsAxes.append([nump,nsh,rank])
            lsApex.append([nump,nsh, rank, 1, I_I0,duromb,''])
            lsApexAll.append([nump,nsh, rank, 1, I_I0,duromb,''])
            invar['NBapexAct'][nump]+=1
            
            #Lucas:
            #shoottype = 'primary' if nsh==0 and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1 else 'branch' ###permet de desactiver le D2 si il fait "double emploi" avec un axe primaire... Sans compter la tige seminale!!! (d'ou le nshoots-2)
            ###limite a la tige seminale : if nsh==0
            # corrGL: baser sur distance au collet
            dist_collet = o3d.distance(p1=array(carto[nump]), p2=array([X0,Y0,Z0]))
            shoottype = 'primary' if nsh==0 and dist_collet< 3. else 'branch'
            
            #mise a jour du NI max            
            IOxls.append_dic(invar_sc['sh']['MaxNI'], idsh, rank+1)
            
            #mise a jour rgeq max plante
            if int(ParamP[nump]['type'])==3 and (rank-3)>invar['rgeq'][nump]:#graminee -> mise a jour rqeq
                invar['rgeq'][nump] = rank-3 #decalage de 3 feuilles par rapport au max pourrait etre un paametre?
            
            #calcul du rankp des organes (feuille/petiole/gaine)
            if int(ParamP[nump]['type'])==3:
                rankp = rgeq #int(invar['rgeq'][nump])
            else:
                rankp = 0
            
            #print('prodLf', nump,nsh,rank,newagef,STEPS)
            produce GetPos(X0,Y0,Z0,nump)In(nump,nsh,newage,rank,0,liniE,'exp',1)[GetPos(X0,Y0,Z0,nump)RB(nump, nsh,0,rank,0)][D2(nump,nsh,newage,rank,phyllotax,shoottype)][Stp(nump, phyllotax, liniS, 'exp')Pet(nump,nsh,newage, phyllotax,liniP,'exp')GetPos(X0,Y0,Z0,nump)GetUp(0,0,0)Lf(nump,nsh,newagef, phyllotax,rank,rankp,liniF,0.,0.,'exp',1)]GetPos(X0,Y0,Z0,nump)A(nump,nsh,1,newage, 0, rank+1, rgeq,phyllotax+ParamP[nump]['phyllotaxy'])
        else:#ombre
            #mort legume: si tige est ombre, n'est plus bourgeon et n'a plus de feuille (test 1), sinon en arret
            if rank>3 :# and int(ParamP[nump]['type'])!=3:
                try:
                    if invar_sc['sh']['SurfVerte'][idsh]==0.:#si ombre et tige sans surface
                        test=1
                    else:
                        test=0
                except:
                    test=0
                
                if test==1:#invar_sc['sh']['SurfVerte'][idsh]==0.:#si ombre et tige sans surface #invar_sc['sh']['Surf']
                    invar['lsApexMort'][nump].append(nsh)
                    try:
                        invar['lsA'][nump].remove(nsh)
                    except:
                        print (str(nsh), 'pas trouve dans lsA')
                    produce *
                else:#sinon pause/arret
                    lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                    lsApexAll.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                    produce GetPos(X0,Y0,Z0,nump)A(nump,nsh,0,age, duromb+STEPS, rank, rgeq,phyllotax)
            elif rank<=3 and int(ParamP[nump]['type'])==3 :#regression talles grass: si tige est ombre, regression de jeunes talles arretee (meme si elle a des feuilles)
                invar['lsApexMort'][nump].append(nsh)
                #print("passe mort",nump,nsh,rank,rgeq)
                try:
                    invar['lsA'][nump].remove(nsh)
                except:
                    print (str(nsh), 'pas trouve dans lsA')
                produce *
            else:#sinon pause/arret 
                lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                lsApexAll.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                produce GetPos(X0,Y0,Z0,nump)A(nump,nsh,0,age, duromb+STEPS, rank, rgeq,phyllotax) #arret de developpement
            #lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
            #produce GetPos(X0,Y0,Z0)A(nump,nsh,0,age, duromb+STEPS, rank, phyllotax) #arret de developpement
    else: #pas atteint age de produire un phytomere
        lsAxes.append([nump,nsh,rank]) 
        lsApex.append([nump,nsh,rank,1, I_I0,duromb,''])
        lsApexAll.append([nump,nsh,rank,1, I_I0,duromb,''])
        invar['NBapexAct'][nump]+=1
        produce GetPos(X0,Y0,Z0,nump)A(nump,nsh,statut,age+STEPS, duromb, rank, rgeq,phyllotax)


GetPos(X0,Y0,Z0,nump2)A2(nump, nsh, statut, age, duromb, rank, rankp, phyllotax):
    global ls_ftswStress, lsApex, lsApexStop, lsApexAll
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARup = meteo_j['I0'] if vox[2] == 1 else res_trans[vox[2]-1][vox[1]][vox[0]] / surf_refVOX
    PARdown = res_trans[vox[2]][vox[1]][vox[0]] / surf_refVOX
    PARapex = PARup - (PARup-PARdown)*(Z0%dxyz[2]) / dxyz[2] #interpolation lineaire a l'iterieur du voxel
    I_I0 = PARapex/meteo_j['I0']
    
    
    stressW = ls_ftswStress['WaterTreshDevII'][nump]
    stressN = ls_NNIStress['NTreshDevII'][nump]
    if opt_stressW == 0:
        stressW = 1.
    if opt_stressN == 0:
        stressN = 1.
    if opt_ReadstressN == 1.:
        stressN = mng_j['ForceNNI']#0.2
    if opt_ReadstressW == 1.:
        stressW = mng_j['ForceFTSW']#0.2    
    
    if nsh in invar['lsApexMort'][nump] or int(ParamP[nump]['ActiveBranch'])!=True: #Meurt si tige porteuse meurt ou AvtiveBranch pas active
        #print 'vrai', nsh
        produce *
    elif age >= ParamP[nump]['phyllochronII']/(0.00001+stressW*stressN): # introduit arret developpement des apex en fonction gradient vertical PAR
        if PARapex>=meteo_j['I0']*ParamP[nump]['par_tresh']:
            newage = age%ParamP[nump]['phyllochronII']+STEPS
            liniF = sh.expansion(newage, ParamP[nump]['aF'], ParamP[nump]['delaiF'])*stressW*stressN
            liniS = sh.expansion(newage, ParamP[nump]['aS'], ParamP[nump]['delaiS'])*stressW*stressN
            liniP = sh.expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP'])*stressW*stressN
            liniE = sh.expansion(newage, ParamP[nump]['aE'], ParamP[nump]['delaiE'])*stressW*stressN#ajout lucas: necessaire chez le TB! sinon, les entrenoeuds demarrent au milieu de leur croissance... 
            lsApex.append([nump,nsh,rank,2, I_I0,duromb, rankp])
            lsApexAll.append([nump,nsh,rank,2, I_I0,duromb, rankp])
            invar['NBapexAct'][nump]+=1
            
            produce GetPos(X0,Y0,Z0,nump)In(nump,nsh,newage,rank,rankp,liniE,'exp',2)GetPos(X0,Y0,Z0,nump)[Stp(nump, phyllotax, liniS, 'exp')Pet(nump,nsh,newage, phyllotax,liniP,'exp')GetPos(X0,Y0,Z0,nump)GetUp(0,0,0)Lf(nump,nsh,newage, phyllotax,rank,rankp,liniF,0.,0.,'exp',2)]GetPos(X0,Y0,Z0,nump)A2(nump, nsh, 1,newage, 0, rank+1, rankp, phyllotax+ParamP[nump]['phyllotaxy'])
        else:
            if duromb<ParamP[nump]['MaxSurvOmbr']:
                lsApexStop.append([nump,nsh,rank,2, I_I0, duromb+STEPS,rankp])
                lsApexAll.append([nump,nsh,rank,2, I_I0, duromb+STEPS,rankp])
                produce GetPos(X0,Y0,Z0,nump)A2(nump, nsh, 0,age, duromb+STEPS, rank, rankp, phyllotax) #arret de developpement du a ombre
            else:
                produce *
    elif PARapex<meteo_j['I0']*ParamP[nump]['par_tresh']:#ombre et hors production de nouveau phytomere
        if duromb<ParamP[nump]['MaxSurvOmbr']:
            lsApexStop.append([nump,nsh,rank,2, I_I0, duromb+STEPS,duromb,rankp])
            lsApexAll.append([nump,nsh,rank,2, I_I0, duromb+STEPS,duromb,rankp])
            produce GetPos(X0,Y0,Z0,nump)A2(nump,nsh,0,age, duromb+STEPS, rank, rankp, phyllotax)
        else:#apex detruit au dela de MaxSurvOmbr
            produce * 
    else:#age avance car pas encore atteint de phyllochron   
        lsApex.append([nump,nsh,rank,2,I_I0,duromb,rankp])
        lsApexAll.append([nump,nsh,rank,2,I_I0,duromb,rankp])
        invar['NBapexAct'][nump]+=1
        
        produce GetPos(X0,Y0,Z0,nump)A2(nump,nsh,statut,age+STEPS, 0, rank, rankp, phyllotax) 




SHP(nump,nsh, azi,elv0,posi,nbp,par):
     if nsh in invar['lsApexMort'][nump]:
        produce * #pour nettoyer lstring si tige morte
     else:
        vox = riri.WhichVoxel(carto[nump], origin_grid, na, dxyz)
        newpar = res_trans[-1][vox[1]][vox[0]]/surf_refVOX
        produce SHP(nump,nsh, azi,elv0,posi, nbp+1, newpar)
#??erreur nbp (nb phytomere devrait dependre meme regle que phyllochrone! (bon seulement pour cet exemple)

GetPos(X0,Y0,Z0,nump): #Rq: le GetPos doit etre dans les regle de production (pas interpretation pour que coupe soit effective)
    if Z0>Hcut and isTTcut == True:
        produce Cut()
    
    #effet gel
    if Z0>=0. and invar['isGelDam'][nump]==1: #coupe tout au dessus du collet:
        produce Cut()





GetPos(X0,Y0,Z0,nump2)GetUp(V1,V2,V3)Lf(nump,nsh,age,azi,rank,rankp,l,tt_omb,Lcut,statut,ordre) :
    global  SurfprofilPlant, ls_ftswStress, lsOrgans, I_I0profilLfPlant, ls_pointes1 #SurfPlante, PARaPlante, PARiPlante, Hplante, Dplante,
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    
    #mise a jour du diametre plante max
    dX, dY = X0-carto[nump][0],Y0-carto[nump][1]
    dist2 =  dX*dX+dY*dY
    if dist2 > invar['Dplante'][nump]**2:
        invar['Dplante'][nump] = sqrt(dist2)
    
    #calul surface
    surF = sh.calc_surF(ParamP[nump], rank, rankp, ordre, l-Lcut, type=ParamP[nump]['type']) #m2
    
    
    
    #gestion feuilles multiples: construction du ls_pts pour distrib surface
    if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2:#legumineuse
        rk = rank+rankp if ordre==2 else rank
    elif int(ParamP[nump]['type'])==3:#lgraminee
        rk = rank+rankp #utilise rankp pour teni compte effet tallage et coupe
    
    #print nsh, rk,rank, rankp, invar['rgeq'][nump], ParamP[nump]['profilLeafI_l'][rk], ParamP[nump]['profilLeafI_larg'][rk], ParamP[nump]['profilLeafI_l'][rk]*ParamP[nump]['profilLeafI_larg'][rk], surF, invar['SurfPlante']
    
    rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou profil pas assez long
    nf = ParamP[nump]['profilLeafI_nfol'][rk]
    ls_pts = []
    if nf > 3 or surF >= tresh_LA:#15cm2
        cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
        #Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
        #Larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
        
        if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2 : #legume or non fixing-legume
            Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
            Larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
            ls_pts.append( o3d.leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'], geom=False))
        elif int(ParamP[nump]['type'])==3:#grass
            Long  = ParamP[nump]['profilLeafI_l'][rk]*(l-Lcut)*(l-Lcut)*cor_ordre #met tout l'effet sur Long
            Larg = ParamP[nump]['profilLeafI_larg'][rk]*cor_ordre
            #ls_pts.append( o3d.leg_grass(Long, Larg, angfol=-5., nfol=nf, anginit=ParamP[nump]['gammaFeuil'], geom=False))
            #pointes, ls_ptsall , ls_cos, ls_sin = o3d.leg_grass_withoutgeom(Long, Larg, angfol=-5., nfol=nf, anginit=ParamP[nump]['gammaFeuil'])
            #ls_pts.append(pointes)
            pointesL = ls_pointes1[nump][0]*Long#*l #l deja dans Long
            #pour repasser matrice en liste (for pas top)
            lspts = []
            for i in range(len(pointesL)):
                lspts.append(pointesL[i])
            ls_pts = [lspts]
        
        #orientation
        #p1, lvec, rrec, r_azi, inclivec = o3d.conv_cyl(array([0.,0.,0.]), array([V1,V2,V3]), 1.)
        #print(nsh,rank, r_azi,r_azi*180./pi,azi,azi%360., azi%360.-90.)
        r_azi = (azi%360.-90.)*pi/180.#radians
        for i in range(len(ls_pts[0])):
            #pt = o3d.RotateAxis (ls_pts[0][i], r_azi, 0)#rotation a faire
            dlp = abs(ls_pts[0][i][1])
            pt = array([dlp*sin(r_azi), -dlp*cos(r_azi), ls_pts[0][i][2]]) #z inchange - applique rotation azi a x,y
            #print(nsh,rank, i, ls_pts[0][i], pt, newpt)
            ls_pts[0][i] = pt + array([X0,Y0,Z0]) #translation point ini feuille
    
    #mise a jour Hmax
    if nf > 3 or surF >= tresh_LA:#15cm2
        for i in range(len(ls_pts[0])):
            if ls_pts[0][i][2]>invar['Hplante'][nump]:
                invar['Hplante'][nump] = ls_pts[0][i][2]
    else:
        if Z0>invar['Hplante'][nump]:
            invar['Hplante'][nump] = Z0
    
    
    #gestion coupe
    if Z0>Hcut and isTTcut==True:
        invar['Hplante'][nump]=Hcut
    
    if int(ParamP[nump]['type'])==3 and isTTcut==True :#grass: 
        #pour grass, coupe tt le bout de feuille qui avait pousse
        reste = (Hcut-Z0)/ParamP[nump]['profilLeafI_l'][rk]
        Lcutnew = max(l-reste, 0.0001) #Longueur normalisee
    else:
        Lcutnew = Lcut
    
    
    #mise a jour stress
    stressW = ls_ftswStress['WaterTreshExpSurf'][nump]
    stressN = ls_NNIStress['NTreshExpSurf'][nump]
    if opt_stressW == 0:
        stressW = 1.
    if opt_stressN == 0:
        stressN = 1.
    if opt_ReadstressN == 1.:
        stressN = mng_j['ForceNNI']#0.2
    if opt_ReadstressW == 1.:
        stressW = mng_j['ForceFTSW']#0.2
    
    #if rank==28:
    #print(nump, nsh,rank, age, l, invar['Hplante'][nump], surF, stressN)
    
    #sen participe a surface et LAI (interception) mais pas au PARa (absorption)
    if age> ParamP[nump]['spanMrt'] or tt_omb> ParamP[nump]['ombF_Ttresh']+ParamP[nump]['spanMrt']-ParamP[nump]['spanSen'] :
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mfeuilmorte = surF*10000/ParamP[nump]['SLAmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mfeuilmorte
        invar['dMSenFeuil'][nump] += mfeuilmorte
        produce *
    else:
        newage = age+STEPS
        
        #calcul des PARif, PARaf et complete
        if nf > 3 or surF >= tresh_LA:#15cm2#  #feuilles multifoliee
            ls_vox, ls_strate, ls_PARif, ls_PARaF = [], [], [], []
            surf_elementaire = surF / float(len(ls_pts[0]))
            for i in range(len(ls_pts[0])):
                #print ls_pts[i], array([X0,Y0,Z0])
                vox = riri.WhichVoxel(ls_pts[0][i], origin_grid, na, dxyz)
                ls_vox.append(vox)
                ls_strate.append(vox[2])
                ls_PARif.append(res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX )
                
                # -> y a des nan iexpliques?? -> pas de surface ds ce voxel au coup d'avant? -> feuille a change de vosel?? (
                sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]#surface folaire dans le voxel
                if sVOX>0.:
                    ls_PARaF.append(res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surf_elementaire/sVOX *3600.*24/1000000.)
                else: #feuille dans voxel sans surface?
                    ls_PARaF.append( res_trans[vox[2]][vox[1]][vox[0]] * surf_elementaire * 3600.*24/1000000.)
            
            PARif = max(ls_PARif)#min ou moy?
            strate = max(ls_strate)#?? pas correct
            PARaF = sum(ls_PARaF)
        else:
            vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
            strate = vox[2] #starte z
            PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise 
            
            # -> y a des nan iexpliques?? -> pas de surface ds ce voxel au coup d'avant? -> feuille a change de vosel?? (elongation noeud?)
            sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]#surface folaire dans le voxel
            if sVOX>0.:
                PARaF = res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surF/sVOX *3600.*24/1000000.
            else: #feuille dans voxel sans surface?
                PARaF = res_trans[vox[2]][vox[1]][vox[0]] * surF * 3600.*24/1000000.
        
        
        I_I0 = PARif/meteo_j['I0']
        classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
        
        
        ###ajout dans ls_organs et profil I_I0: 1 seule feuille (tient pas compte des feuilles multiples)
        if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2:#legumineuse
            ranklong = rank+rankp if ordre==2 else rank
        elif int(ParamP[nump]['type'])==3:#graminee
            ranklong = rank+rankp #utilise rankp pour teni compte effet tallage et coupe
        
        ranklong = min(ranklong, len(ParamP[nump]['profilLeafI_l'])-1)#au cas ou profil trop long
        cor_ordre=ParamP[nump]['ratioII'] if ordre==2 else 1.
        if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2:#legumineuse
            Longueur = ParamP[nump]['profilLeafI_l'][ranklong]*l*cor_ordre
            Largeur = ParamP[nump]['profilLeafI_larg'][ranklong]*l*cor_ordre
        elif int(ParamP[nump]['type'])==3:#graminee
            Longueur = ParamP[nump]['profilLeafI_l'][ranklong]*(l-Lcut)*(l-Lcut)*cor_ordre
            Largeur = ParamP[nump]['profilLeafI_larg'][ranklong]*cor_ordre
        
        lsOrgans.append([TT,'Lf',nump,nsh,rank,rankp,strate,surF,PARaF,statut,newage,ordre,l,Longueur,DOY,cutNB,Largeur]) #decalage de un step pour l en exp
        invar['SurfPlante'][nump].append(surF)
        I_I0profilLfPlant[nump][classI_I0] += surF
        
        #print(nsh, invar['SurfPlante'][nump])
        
        #profil vertical de surface
        if nf > 3 or surF >= tresh_LA:#15cm2#  #feuilles multifoliee
            surf_elementaire = surF / float(len(ls_pts[0]))
            for i in range(len(ls_pts[0])):
                strate = ls_strate[i]
                SurfprofilPlant[nump][strate] += surf_elementaire
        else:
            SurfprofilPlant[nump][strate] += surF
        
        
        if age> ParamP[nump]['spanSen'] : 
            if nf > 3 or surF >= tresh_LA:#15cm2#  #feuilles multifoliee 
                surf_elementaire = surF / float(len(ls_pts[0]))
                for i in range(len(ls_pts[0])):
                    vox = ls_vox[i]
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
            else:
                m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF 
            
            invar['PARiPlante'][nump].append(PARaF)
            produce GetPos(X0,Y0,Z0,nump)GetUp(V1,V2,V3)Lf(nump,nsh,newage,azi,rank,rankp,l,tt_omb,Lcutnew,'sen',ordre)
        elif tt_omb> ParamP[nump]['ombF_Ttresh']:
            #print "ombre!"
            if nf > 3 or surF >= tresh_LA:#15cm2#  #feuilles multifoliee 
                surf_elementaire = surF / float(len(ls_pts[0]))
                for i in range(len(ls_pts[0])):
                    vox = ls_vox[i]
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
            else:
                m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF 
            
            invar['PARiPlante'][nump].append(PARaF)
            produce GetPos(X0,Y0,Z0,nump)GetUp(V1,V2,V3)Lf(nump,nsh,newage,azi,rank,rankp,l,tt_omb+STEPS,Lcutnew,'sen',ordre)
        else:
            invar['PARaPlante'][nump].append(PARaF)
            invar['PARiPlante'][nump].append(PARaF)
            adTTomb = STEPS if PARif <= ParamP[nump]['ombF_Ltresh'] else 0
            
            if statut == 'exp':
                pot = sh.expansion(age+STEPS, ParamP[nump]['aF'], ParamP[nump]['delaiF']) - sh.expansion(age, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
                dl = pot*stressW*stressN
                newsurF = sh.calc_surF(ParamP[nump], rank, rankp, ordre, (l-Lcut)+dl, type=ParamP[nump]['type'])
                
                
                #print(nump, nsh,rank, age, newage, l, dl)# invar['Hplante'][nump], pot, dl, surF, stressN)
                
                if nf > 3 or surF >= tresh_LA:#15cm2#  #feuilles multifoliee 
                    surf_elementaire = newsurF / float(len(ls_pts[0]))
                    for i in range(len(ls_pts[0])):
                        vox = ls_vox[i]
                        m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
                else:
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += newsurF
                
                stat = 'mat'if pot<0.005 and age>ParamP[nump]['delaiF'] else 'exp'
                produce GetPos(X0,Y0,Z0,nump)GetUp(V1,V2,V3)Lf(nump,nsh,newage,azi,rank,rankp,l+dl,tt_omb+adTTomb,Lcutnew,stat,ordre)
            elif statut == 'mat':
                if nf > 3 or surF >= tresh_LA:#15cm2#  #feuilles multifoliee 
                    surf_elementaire = surF / float(len(ls_pts[0]))
                    for i in range(len(ls_pts[0])):
                        vox = ls_vox[i]
                        m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
                else:
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF
                
                produce GetPos(X0,Y0,Z0,nump)GetUp(V1,V2,V3)Lf(nump,nsh,newage,azi,rank,rankp,l,tt_omb+adTTomb,Lcutnew,statut,ordre)


Stp(nump,azi,l, statut) > Pet(nump1, nsh, age, azi1, l1, statut1)GetPos(X0,Y0,Z0,nump3)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,azi2,rank,rankp,l2,tt_omb,Lcut,statut2,ordre):
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    stressW = ls_ftswStress['WaterTreshExpSurf'][nump]
    stressN = ls_NNIStress['NTreshExpSurf'][nump]
    if opt_stressW == 0:
        stressW = 1.
    if opt_stressN == 0:
        stressN = 1.
    if opt_ReadstressN == 1.:
        stressN = mng_j['ForceNNI']#0.2
    if opt_ReadstressW == 1.:
        stressW = mng_j['ForceFTSW']#0.2
    
    if ParamP[nump]['gotStip']== 1. and age < ParamP[nump]['spanMrt']:#presence stipules
        #strate = max(0, int(ceil((Z0+0.00001)/dz))-1)
        vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
        strate = vox[2] #starte z
        
        surF = sh.calc_surS(ParamP[nump], rank, rankp, ordre, l) #m2
        PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
        I_I0 =  PARif/meteo_j['I0']
        classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
        
        sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]
        if sVOX>0.:
            PARaF = res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surF/sVOX *3600.*24/1000000.
        else:
            PARaF = res_trans[vox[2]][vox[1]][vox[0]] * surF * 3600.*24/1000000.
        #print PARaF, PARaF_bis, sVOX#
        
        lsOrgans.append([TT,'Stp',nump,nsh2,rank,rankp,strate,surF,PARaF,statut,age2+STEPS,ordre,l,'NA',DOY,cutNB,'NA'])
        SurfprofilPlant[nump][strate] += surF #suppose mis dans meme strate que feuille
        I_I0profilLfPlant[nump][classI_I0] += surF
        invar['SurfPlante'][nump].append(surF)
        invar['PARiPlante'][nump].append(PARaF)
        invar['PARaPlante'][nump].append(PARaF)
        
        
        if statut == 'exp':
            pot = sh.expansion(age2+STEPS, ParamP[nump]['aS'], ParamP[nump]['delaiS']) - sh.expansion(age2, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            dl = pot*stressW*stressN
            newsurF = sh.calc_surS(ParamP[nump], rank, rankp, ordre, l+dl)
            m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += newsurF
            
            if pot<0.005 and age>ParamP[nump]['delaiS'] :
                produce Stp(nump,azi,l+dl, 'mat')
            else :
                produce Stp(nump,azi,l+dl, 'exp')
        else : #reste en 'mat'
            m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF
            produce Stp(nump,azi,l, 'mat')
    elif ParamP[nump]['gotStip']== 1. and age >= ParamP[nump]['spanMrt']: # stipule mort ou 'spanMrt' -> retire de la chaine et met ddans residus feuille
        surF = sh.calc_surS(ParamP[nump], rank, rankp, ordre, l)#m2      
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mfeuilmorte = surF*10000/ParamP[nump]['SLAmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mfeuilmorte
        produce *
    else: 
        produce *


Pet(nump,nsh,age, phyllotax, l, statut) > GetPos(X0,Y0,Z0,nump3)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,azi,rank,rankp,l2,tt_omb,Lcut,statut2,ordre):
    global ls_ftswStress
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    newage = age+STEPS
    lpet = sh.calc_Lpet(ParamP[nump], rank, rankp, ordre, l, type=ParamP[nump]['type'])#m
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
    I_I0 =  PARif/meteo_j['I0']
    classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
    I_I0profilPetPlant[nump][classI_I0] += lpet
    #photomorphogenese
    
    RFR=res_rfr[vox[2]][vox[1]][vox[0]]
    RFR_effect=(ParamP[nump]['photomorphRFR_pets']*RFR)+ParamP[nump]['photomorphRFR_peti']
    
    durjour = meteo_j['durjour']#sh.DayLength (latitude,sh.DecliSun (DOY % 365))
    PAReff = PARif * 24./durjour #courbe de reponse au PAR calle sur moyenne sur photoperiode
    PAR_effect= sh.trilineaire(PAReff,ParamP[nump]['photomorphPAR_petini'],ParamP[nump]['photomorphPAR_petM'],ParamP[nump]['photomorphPAR_pett1'],ParamP[nump]['photomorphPAR_pett2'])
    
    if opt_photomorph ==1:
        photomorph = RFR_effect*PAR_effect
    else:
        photomorph = 1.
    
    invar['phmgPet'][nump].append(photomorph)
    invar['phmgPet_m'][nump].append(photomorph)
    
    lsOrgans.append([TT,'Pet',nump,nsh,rank,rankp,'NA','NA','NA',statut,newage,ordre,l,lpet,DOY,cutNB,'NA'])#decalage de un step pour l avec age en exp ou mort
    
    stressW = ls_ftswStress['WaterTreshExpSurf'][nump]
    stressN = ls_NNIStress['NTreshExpSurf'][nump]
    if opt_stressW == 0:
        stressW = 1.
    if opt_stressN == 0:
        stressN = 1.
    if opt_ReadstressN == 1.:
        stressN = mng_j['ForceNNI']#0.2
    if opt_ReadstressW == 1.:
        stressW = mng_j['ForceFTSW']#0.2
    
    if age> ParamP[nump]['spanMrt'] or nsh in invar['lsApexMort'][nump]:#mort du module
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mpetmort = lpet/ParamP[nump]['SPLmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mpetmort
        invar['dMSenTige'][nump] += mpetmort#g
        produce *
    
    elif statut == 'exp':
        pot = sh.expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP']) - sh.expansion(age, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
        if int(ParamP[nump]['type'])==3:#graminee
            dl = pot #to avoid interaction with cut in grass
        else:
            dl = pot * stressW * stressN * photomorph
        
        if pot<0.005 and age>ParamP[nump]['delaiP']:#passe en 'mature'
            produce Pet(nump,nsh,newage, phyllotax, l+dl, 'mat')
        else: #reste en 'exp'
            produce Pet(nump,nsh,newage, phyllotax, l+dl, statut)
    else:#reste en 'mat'
        produce Pet(nump,nsh,age+STEPS, phyllotax,l,statut)


GetPos(X0,Y0,Z0,nump2)In(nump,nsh,age,rank,rankp, l, statut,ordre):
    global ls_ftswStress, lsOrgans      
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    newage = age+STEPS
    lent = sh.calc_Lent(ParamP[nump], rank, nsh, ordre, l)#m
    #rq: ?? Lent seul organe a ne pas tenir compte de rankp pour ajuster profil selon topologie??
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
    I_I0 =  PARif/meteo_j['I0']
    classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.    
    
    RFR=RFR=res_rfr[vox[2]][vox[1]][vox[0]]
    RFR_effect=(ParamP[nump]['photomorphRFR_ints']*RFR)+ParamP[nump]['photomorphRFR_inti']
    
    durjour = meteo_j['durjour']#sh.DayLength (latitude,sh.DecliSun (DOY % 365))
    PAReff = PARif * 24./durjour #courbe de reponse au PAR calle sur moyenne sur photoperiode
    PAR_effect= sh.trilineaire(PAReff,ParamP[nump]['photomorphPAR_intini'],ParamP[nump]['photomorphPAR_intM'],ParamP[nump]['photomorphPAR_intt1'],ParamP[nump]['photomorphPAR_intt2'])
    
    if opt_photomorph ==1:
        photomorph = RFR_effect*PAR_effect
    else:
        photomorph = 1.
    
    invar['phmgEntr'][nump].append(photomorph)
    invar['phmgEntr_m'][nump].append(photomorph)
    
    lsOrgans.append([TT,'In',nump,nsh,rank,rankp,'NA','NA','NA',statut,newage,ordre, l,lent,DOY,cutNB,'NA']) #decalage de un step pour l et age en exp!
    invar['NBphyto'][nump] += 1 #comptage du phytomere 
    
    
    stressW = ls_ftswStress['WaterTreshExpSurf'][nump]
    stressN = ls_NNIStress['NTreshExpSurf'][nump]
    if opt_stressW == 0:
        stressW = 1.
    if opt_stressN == 0:
        stressN = 1.
    if opt_ReadstressN == 1.:
        stressN = mng_j['ForceNNI']#0.2
    if opt_ReadstressW == 1.:
        stressW = mng_j['ForceFTSW']#0.2
    
    
    if nsh in invar['lsApexMort'][nump]: #Meurt si tige meurt meurt
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        minmort = lent/ParamP[nump]['SNLmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4+1][voxsol[2]][voxsol[1]][voxsol[0]] += minmort
        invar['dMSenTige'][nump] += minmort
        produce *
    elif statut == 'exp':
        pot = sh.expansion(age+STEPS, ParamP[nump]['aE'], ParamP[nump]['delaiE']) - sh.expansion(age, ParamP[nump]['aE'], ParamP[nump]['delaiE'])
        dl = pot * stressW * stressN * photomorph
        
        if pot<0.005 and age>ParamP[nump]['delaiE']:#passe en 'mature'
            produce GetPos(X0,Y0,Z0,nump)In(nump,nsh,newage,rank,rankp, l+dl, 'mat',ordre)
        else: #reste en 'exp'
            produce GetPos(X0,Y0,Z0,nump)In(nump,nsh,newage,rank,rankp, l+dl, statut,ordre)
    else: #reste en 'mat'
        produce GetPos(X0,Y0,Z0,nump)In(nump,nsh,age+STEPS,rank,rankp, l, statut,ordre)


D(nump,nsh, statut,age,posi,parent):
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    invar['NBD1'][nump]+=1
    nbExp_Prev = outvar['NBBexp'][-1][0][nump+2]+1 #nb bourgeons type exp juste avant
    
    
    if parent in invar['lsApexMort'][nump]: #Meurt si parent meurt
        #invar['lsApexMort'][nump].remove(parent) #l'enleve pas de la liste car sinon pas visible pour autres organes
        invar['countShExp'][nump] -= 1
        produce *
    #elif nbExp_Prev<=ParamP[nump]['NBexp'] and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1:#cree bourgeon si NBB exp pas atteint
    #    print 'vrai'
    #    outvar['NBBexp'][-1][0][nump+2] +=1
    #    invar['NBBexp'][nump] +=1
    #    newage = age%ParamP[nump]['phyllochron']+STEPS
    #    new_nrhiz = binomial(ParamP[nump]['DistLRhiz'][0], ParamP[nump]['DistLRhiz'][1])#2#0
    #    newazi = random.uniform(0.,360.)
    #    produce @M(posi[0],posi[1],posi[2])SetHead()/(newazi)&(90)B(nump, nsh, newage, posi, new_nrhiz,newazi, 0,'exp')
    elif not parent in invar['lsAPrev'][nump] :#and statut==0: #sort de dormance si tige parente coupee
        #newage = age%ParamP[nump]['phyllochron']+STEPS
        #produce D(nump,nsh,1,newage,posi,parent)
    #elif statut ==1:#pas d'apres produit un nouvel axe
        NIparent = max(invar_sc['sh']['MaxNI'][str(nump)+'_'+str(parent)])
        deltaBud = sh.MaturBud(ParamP[nump]['delaiMaturBud'], NIparent)
        
        #newage = age%ParamP[nump]['phyllochron']+STEPS
        newage = deltaBud*ParamP[nump]['phyllochron'] + age%ParamP[nump]['phyllochron']# + STEPS  # #rajoute pas le steps car compare a zero apres
        new_nrhiz = binomial(ParamP[nump]['DistLRhizn'], ParamP[nump]['DistLRhizp'])#2#0
        newazi = random.uniform(0.,360.)
        
        #print 'D', nsh, parent, NIparent, deltaBud, newage
        
        produce @M(posi[0],posi[1],posi[2])SetHead()/(newazi)&(90)B(nump, nsh, newage, posi, new_nrhiz,newazi, 0,'regular') #un bourgeon ave un nsh qui ne rajoute pas de nvelle tige
    else:
        produce D(nump,nsh, statut,age+STEPS,posi,parent)


D2(nump, nsh, age, rankp, phyllotax,shoottype):
    STEPS = invar['Udev'][nump]#invar['dTT'][nump]
    
    if nsh in invar['lsApexMort'][nump] or shoottype=="primary": #Meurt si tige porteuse meurt #disparait si il y a aussi un D avec lequel D2 fait "double emploi"
        produce *
    elif age <= ParamP[nump]['delai_deb']-ParamP[nump]['phyllochronII']:
        #print("agetropjeune",age)
        produce D2(nump,nsh,age+STEPS,rankp, phyllotax,shoottype)
    elif int(ParamP[nump]['ActiveBranch'])==True:
        init_age = age-(ParamP[nump]['delai_deb']-ParamP[nump]['phyllochronII'])
        #print("agedepasse",init_age, age)
        elv0 = 45
        if rankp%2==0:
            produce +(90-elv0)GetPos(0,0,0,nump)A2(nump, nsh, 1, init_age, 0, 0, rankp, phyllotax+30)
        else:
            produce -(90-elv0)GetPos(0,0,0,nump)A2(nump, nsh, 1, init_age, 0, 0, rankp, phyllotax+30)

RA(nump, nsh, age, rankp, agecum, moduloH):
    STEPSsol = invar['dTTsol'][nump]
    
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    # quelle prof max de sol si il y a un obstarac?
    if S.obstarac is None or type(S.obstarac != type(array([0.]))):
        prof_obst = prof_sol_max
    else:
        #dans quel voxl de sol est la plante
        vox = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        prof_obst =  -S.obstarac[vox[0], vox[1]]*100.
        #print 'sol depth', prof_sol_max, vox, S.obstarac[vox[0], vox[1]]#, na, [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], vox
    
    #stressHydrique
    Horizmax = int(min([prof_sol_max, prof_obst])/dz_sol)-1
    Horiz = min(int(moduloH/dz_sol), Horizmax)
    stressH = sh.FTSW_resp(mean(S.ftsw_t[Horiz,:,:]), [ParamP[nump]['WaterTreshElRootss'], ParamP[nump]['WaterTreshElRootsd']])
    stressHLim = 0.05 #limite de croissance (a calculer dans ParamP)
    
    #MAJ de RDepth
    if moduloH>invar['RDepth'][nump]:
        invar['RDepth'][nump]=moduloH
    
    #ajout d'un cyclindre dans syst racinaire pour racine primaire/pivot
    if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2 : #legume
        larg_ = 0.01
    elif int(ParamP[nump]['type'])==3 : #fascilule: grass
        idI = rt.idLong(moduloH+0.001, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
        larg_ = max(0.01, ParamP[nump]['profilRoot']['y'][idI])#['y'][id[0]]#['y'][id]
    
    ls_systrac[nump].append([carto[nump][0],carto[nump][1],0.,larg_, max(moduloH,0.01)])
    
    #ajout dans ls_organs
    lsOrgans.append([TT,'Piv',nump,nsh,rankp,0,'NA','NA','NA','NA',agecum+STEPSsol,1,0,moduloH,DOY,cutNB,'NA'])
    
    
    #calcul ratio QD instantane
    if(agecum<ParamP[nump]['DurGraine']):
        ratio=1.
    else:
        ratio = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax) 
    
    #seuil pour emission d'un nouveau root segment
    tresh=ParamP[nump]['Relongation_duration0']/max(0.0001, ratio)#effet lineaire sur profondeur: OK meme pour tropisme grass 
    #print moduloH, moduloH%dz_sol, prof_sol_max
    if stressH < stressHLim :
        #arret en sol sec
        produce RA(nump, nsh, age, rankp, agecum, moduloH) #stop = change pas : tout ou rien attends eau
    elif age>tresh and moduloH%dz_sol==0. and moduloH<min([prof_sol_max, prof_obst]) and stressH >= stressHLim:
        #print moduloH, dz_sol, moduloH%dz_sol, int(moduloH/dz_sol)
        produce RLB(nump,nsh,0,rankp, int(moduloH/dz_sol))RS(nump,nsh, rankp,moduloH)RA(nump,nsh, age%tresh+STEPSsol, rankp, agecum+STEPSsol, moduloH+ParamP[nump]['LRS'])
    elif age>tresh and moduloH<min([prof_sol_max, prof_obst]) and stressH >= stressHLim:
        produce RS(nump, nsh, rankp, moduloH)RA(nump, nsh, age%tresh+STEPSsol, rankp, agecum+STEPSsol,moduloH+ParamP[nump]['LRS'])
    else:
        produce RA(nump,nsh, age+STEPSsol, rankp, agecum+STEPSsol,moduloH)


RLB(nump,nsh,age,rankp, Horiz):
    STEPSsol = invar['dTTsol'][nump]
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    #calcul ratio QD instantane
    ratio = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax)
    
    tresh=ParamP[nump]['delai_RLAP']/max(0.0001, ratio)
    
    if age>tresh:
        produce [GetPos(0.,0.,0.,nump)RLAP(nump,nsh,age%tresh+STEPSsol, rankp, 0.01, Horiz)]
    else:
        produce RLB(nump,nsh,age+STEPSsol,rankp, Horiz)


GetPos(X0,Y0,Z0,nump2)RLAP(nump,nsh,age,rankp,l, Horiz):
    STEPSsol = invar['dTTsol'][nump]
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    #calcul ratio QD instantane
    ratioC = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax) 
    
    #stressHydrique
    stressH = sh.FTSW_resp(mean(S.ftsw_t[Horiz,:,:]), [ParamP[nump]['WaterTreshElRootss'], ParamP[nump]['WaterTreshElRootsd']])
    
    #ajout pondere pour calcul de stress H racinaire global
    invar_sc['ax']['StressHRac'] = IOxls.add_dic({idax:stressH*l}, invar_sc['ax']['StressHRac'])
    invar_sc['ax']['PonderStressHRac'] = IOxls.add_dic({idax:l}, invar_sc['ax']['PonderStressHRac'])
    
    #print idax, stressH, invar_sc['ax']['StressHRac'][idax] / invar_sc['ax']['PonderStressHRac'][idax]
    
    dl = (STEPSsol/ParamP[nump]['Relongation_durationII'])*ratioC*stressH
    #print dl, invar_sc['ax']['QDCRac'], invar_sc['ax']['AgePiv']#invar_sc['ax']['OfrCRac']#ratioC, stressH
    # nbplantes, invar_sc['ax']['AgePiv'], invar_sc['plt']['PARaF'], invar_sc['ax']['PARaF']
    #RprospectProfil[nump][Horiz] = l+dl
    
    #calculation new enveloppe II
    delatdI = 0.
    if int(ParamP[nump]['type'])==3 : #fascilule: grass
        moduloH = Horiz*dz_sol
        idI = rt.idLong(moduloH+0.001, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
        largI = ParamP[nump]['profilRoot']['y'][idI]#['y'][id[0]]#['y'][id]
        delatdI = max(0.1, largI)
    
    id = rt.idLong(l, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
    larg = ParamP[nump]['profilRoot']['y'][id] + delatdI#['y'][id[0]]#['y'][id]
    long = min(max(dz_sol ,ParamP[nump]['profilRoot']['x'][id]), prof_sol_max+Z0)#['x'][id[0]]), prof_sol_max+Z0)#['x'][id]), prof_sol_max+Z0)
    ls_systrac[nump].append([X0,Y0,-Z0,larg,long])
    
    if age<=(ParamP[nump]['GDs1']+ParamP[nump]['GDs2'])/2:#durre expansion enveloppe secondaire determinee par Dmax et D2 -> devrait utiliser varD pour laterales les plus larges
        produce GetPos(X0,Y0,Z0,nump)RLAP(nump,nsh,age+STEPSsol,rankp, l+dl, Horiz)
    else:
        produce GetPos(X0,Y0,Z0,nump)RLAP(nump,nsh,age+STEPSsol,rankp, l, Horiz)
    #rq: croissance indeterminee! -> tient pas compte de GDs



[GetPos(X0,Y0,Z0,nump2)RB(nump,nsh,age,rankp,statut)]:
    global S
    STEPSsol = invar['dTTsol'][nump]
    
    if int(ParamP[nump]['type'])==3 and rankp!=0: #fascilule - grass -> une seule enveloppe I par talle
        allowed=0#stoppe les I qui ne sont pas celle du 1er noeud
    else:
        allowed=1
    
    Horiz=0
    if Z0 > ParamP[nump]['HeightTreshAdvRoots'] or allowed==0: #supprime bud si au dessus d'une hauteur seuil
        produce *
    elif age>ParamP[nump]['delai_AdvRoots'] and statut==0:
        pb = random.uniform(0.,1.)
        if pb<ParamP[nump]['ProbaMaxAdvRoots'] :
            if mean(S.ftsw_t[Horiz,:,:]) > ParamP[nump]['WaterTreshAdvRoots']:
                produce [;(0)SetHead(0,0,-1, -1,0,0)RA(nump,nsh,-1,rankp,0,0)]
            else:
                produce [GetPos(X0,Y0,Z0,nump)RB(nump,nsh,age+STEPSsol,rankp,1)] #statut
        else: #supprime bud si sous proba seuil
            produce *
    elif statut==1 :#en attente bloque par stress hydrique
        if age>ParamP[nump]['delai_AdvRoots']+ParamP[nump]['fenetre_AdvRoots']:
            produce *
        else:
            if mean(S.ftsw_t[Horiz,:,:]) > ParamP[nump]['WaterTreshAdvRoots']:
                produce [;(0)SetHead(0,0,-1, -1,0,0)RA(nump,nsh,-1,rankp,0,0)]
            else:
                produce [GetPos(X0,Y0,Z0,nump)RB(nump,nsh,age+STEPSsol,rankp,statut)]
    else:#statut 0 en attente du delai de debourrement 'delai_AdvRoots'
        produce [GetPos(X0,Y0,Z0,nump)RB(nump,nsh,age+STEPSsol,rankp,statut)]

[] --> * #pour nettoyer les bracket des D() morts
[Pet(nump, nsh, age, azi, l, statut)] --> * #pour nettoyer les restes de coupe qui on enelver feuille -> ajouter a residus!


sol(sol_obj, nbcol):
    if nbcol>0:
        nproduce [solxy(sol_obj, nbcol-1)]sol(sol_obj, nbcol-1)
    else:
        produce *

attente(n):
    global S, discret_solXY
    if n>0:
        produce attente(n-1)
    else:
        produce pattern(0)sol(S, discret_solXY[1])


interpretation:
SHP(nump,nsh,azi, elv0,posi,nbp,par):
    if elv0 < ParamP[nump]['elvtresh'] and par>=meteo_j['I0']*ParamP[nump]['par_tresh']:#pour moduler incli0 par longueur/incli en plante isolee
        Lsh = ParamP[nump]['Len']*nbp
        Hsh = Lsh*sin(elv0*pi/180.)
        corr_elv = max(0,(ParamP[nump]['Lmaxeffet']-Hsh))/ParamP[nump]['Lmaxeffet'] 
    elif elv0 < 60 and par<meteo_j['I0']*ParamP[nump]['par_tresh']: #pour moduler incli competition forte/ a revoir au niveau de la loi de ditrib ou de elasticite
        corr_elv =1.#1.3
    else:
        corr_elv =1.
        
    produce &(-elv0*corr_elv)


In(nump,nsh,age,rank,rankp, l, statut,ordre):
    lent = sh.calc_Lent(ParamP[nump], rank, nsh, ordre, l)*100. #cm
    if ordre==2:
        color=2
    else:
        color=3
    if ordre==1 and nsh==0:#tige seminale
        color=2
    
    if visu_shoot==1:
        #produce ;(2)@Tp([0,0,1])Ts(lent*ParamP[nump]['elasticity'])F(lent,0.3)
        produce ;(color)@Tp([0,0,1])@Ts(min(1,lent*ParamP[nump]['elasticity']))F(lent,0.3)# modif lucas : min() car avait de drole de comportement sans ca a certaines valeurs
    else:
        produce ;(color)@Tp([0,0,1])@Ts(min(1,lent*ParamP[nump]['elasticity']))f(lent,0.3)# modif lucas : min() car avait de drole de comportement sans ca a certaines valeurs

A(nump,nsh,statut,age, duromb, rank, rgeq,phyllotax):
    if visu_shoot==1:
        if statut ==1:
            produce ;(3)Sphere(0.4)
        else:
            produce ;(4)Sphere(0.4)

A2(nump, nsh, statut, age, duromb,rank, rankp, phyllotax):
    if visu_shoot==1:
        if statut ==1:
            produce ;(1)Sphere(0.3)
        else:
            produce ;(4)Sphere(0.3)


#D(nump,statut,posi) --> @M(posi[0],posi[1],posi[2])#;(1)Sphere(0.2)#les voit pas


Pet(nump, nsh, age, azi,l1, statut1) > GetPos(X0,Y0,Z0,nump3)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,azi2,rank,rankp,l2,tt_omb,Lcut,statut2,ordre):
    lpet = sh.calc_Lpet(ParamP[nump], rank, rankp, ordre, l1, type=ParamP[nump]['type'])*100.#cm
    IncPet = ParamP[nump]['IncPet']
    if visu_shoot==1:
        produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet)_(0.1)F(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)
        #produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet);(2)F(0.00001,0.1)F(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)  
    else:
        produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet)_(0.1)f(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)


Lf(nump, nsh, age, azi,rank, rankp, l, tt_omb, Lcut,statut,ordre):
    if visu_shoot==1:
        cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
        if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2:#legumineuse
            rk = rank+rankp if ordre==2 else rank
            rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou profil pas assez long
            Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
            Larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
        elif int(ParamP[nump]['type'])==3:#lgraminee
            rk = rank+rankp #utilise rankp pour tenir compte effet tallage et coupe
            rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou profil pas assez long
            Long  = ParamP[nump]['profilLeafI_l'][rk]*(l-Lcut)*(l-Lcut)*cor_ordre
            Larg = ParamP[nump]['profilLeafI_larg'][rk]*cor_ordre
        
        nf = ParamP[nump]['profilLeafI_nfol'][rk]
        if statut == 'exp' or statut == 'mat':
            col=2#2
        elif statut == 'sen':
            col = 1
        
        if ordre ==2:
            col = 3#2
            
        #insere pour mixtures
        if int(ParamP[nump]['type'])==1:
            col=2
        else:
            col=6
        
        #insere pour gradient de distrib: gradient selon valeur d'un parametre
        if opt_sd==1:
            parname = 'Len' 
            parval = ParamP[nump][parname] #test_retard[nump]#
            vals = riri.get_lsparami(ParamP, parname) #test_retard#
            col = 30 + int(7* (parval - min(vals)) / (max(vals)+10E-12 -  min(vals)))
        
        
        #choix du geom
        if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2 : #legume or non fixing-legume
            geom = o3d.leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'])
            #print o3d.leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'], geom=False)
        elif int(ParamP[nump]['type'])==3:#grass
            geom = o3d.leg_grass(Long, Larg, angfol=-5., nfol=nf, anginit=ParamP[nump]['gammaFeuil'], geom=True)
            #courbure de limbe en dur (angfol) -> a passer en paramtre?
        
        produce ;(col)@g(geom)


Stp(nump, azi,l, statut)> Pet(nump1, nsh, age, azi1, l1, statut1)GetPos(X0_,Y0_,Z0_,nump3)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,azi2,rank,rankp,l2,tt_omb,Lcut,statut2,ordre):
    if visu_shoot==1: 
        if ParamP[nump]['gotStip']== 1.:
            cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
            rk = rank+rankp if ordre==2 else rank
            rk = min(rk, len(ParamP[nump]['profilStipI_l'])-1) #au cas ou profil pas assez long
            Long = l*ParamP[nump]['profilStipI_l'][rk]*cor_ordre
            Larg = l*ParamP[nump]['profilStipI_larg'][rk]*cor_ordre
            stip = o3d.geomstip(Long, Larg,alpha=90,gamma=ParamP[nump]['gammaFeuil'])
            col = 5#0#2#
            produce SetHead(0,0,1, 1,0,0)/(azi%360-90);(col)@g(stip)
            #y a des implicites pour les angles


Coll(posi) --> @M(posi[0],posi[1],posi[2])[;(0)SetHead(0,0,-1, -1,0,0) #! contient ouverture de [ du systeme racinaire

RA(nump,nsh,age, rankp,agecum,moduloH): 
    if visu_root==1:
        produce ;(3)Sphere(0.4)

RS(nump, nsh, rankp, moduloH):
    #diampiv = max(0.1 ,invar['DiampivMax'][nump]*(1-moduloH/ParamP[nump]['ZPivot_min'])) 
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    if int(ParamP[nump]['type'])==1 or int(ParamP[nump]['type'])==2 : #pivot: legume or non fixing-legume
        diampiv = max(0.1 ,invar_sc['ax']['DiampivMax'][idax]*(1-moduloH/ParamP[nump]['ZPivot_min']))
    elif int(ParamP[nump]['type'])==3 : #fascilule: grass
        id = rt.idLong(moduloH+0.01, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
        larg = ParamP[nump]['profilRoot']['y'][id]#['y'][id[0]]#['y'][id]
        diampiv = max(0.1, larg)
    
    if visu_root==1:
        produce ;(1)_(diampiv)F(ParamP[nump]['LRS'])
    else:
        produce ;(1)_(diampiv)f(ParamP[nump]['LRS'])

RLB(nump,nsh,age,rankp, Horiz): 
    if visu_root==1:
        produce ;(0)Sphere(0.4)

RLAP(nump,nsh,age,rankp, l, Horiz): 
    
    delatdI = 0.
    if int(ParamP[nump]['type'])==3 : #fascilule: grass
        moduloH = Horiz*dz_sol
        idI = rt.idLong(moduloH+0.001, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
        larg = ParamP[nump]['profilRoot']['y'][idI]#['y'][id[0]]#['y'][id]
        delatdI = max(0.1, larg)
    
    id = rt.idLong(l, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
    #print id, l, ParamP[nump]['profilRoot']['y']
    larg = ParamP[nump]['profilRoot']['y'][id] + delatdI#['y'][id[0]]#['y'][id]#
    long = max(dz_sol ,ParamP[nump]['profilRoot']['x'][id])#['x'][id[0]])#['x'][id])
    if visu_root==1:
        produce ;(0)_(larg)F(long)
    else:
        produce ;(0)_(larg)f(long)

solxy(sol_obj, idcol):
    if visu_sol == 1:
        global dz_sol, ncouches_sol, discret_solXY
        #print mean(sol_obj.HRp(), axis=1)[:,0]#mean(mean(sol_obj.HRp(), axis=0), axis=0)
        Nmin_xy = mean(sol_obj.m_NO3, axis=1)#mean(sol_obj.m_NO3+sol_obj.m_NH4)/(sol_obj.m_soil_vol*sol_obj.m_DA)*1000, axis=1)
        norm_Nmin_xy = Nmin_xy/Nmin_xy.max()
        norm_Nmin_xy = norm_Nmin_xy[:,idcol]
        
        ftsw_xy = mean(sol_obj.ftsw_t, axis=1)[:,idcol]
        nbcol = discret_solXY[1]
        larg_box = 30.
        
        #print norm_Nmin_xy #ftsw_xy
        for i in range(ncouches_sol):
            z = -i*dz_sol
            values = ftsw_xy#norm_Nmin_xy#   A changer pour voir variable de sortie souhaitee
            
            #ftsw = max(0., mean(sol_obj.ftsw_t[i,:,:]))
            ftsw = max(0, values[i])
            col = 16 + int(ceil((1-ftsw)/0.1))
            #nproduce ;(col)@M(-50,0,z-dz_sol)@g(Box(1,30,dz_sol))
            nproduce ;(col)@M(-50,float(idcol)*2*larg_box/float(nbcol),z-dz_sol)@g(Box(1,larg_box/float(nbcol),dz_sol))



sol(sol_obj, nbcol):
    if visu_sol == 1:
        #l'affiche au premier step pour bien definir champs de la camera
        global dz_sol, ncouches_sol
        #print mean(sol_obj.HRp(), axis=1)[:,0]#mean(mean(sol_obj.HRp(), axis=0), axis=0)
        for i in range(ncouches_sol):
            z = -i*dz_sol
            ftsw = max(0., mean(sol_obj.ftsw_t[i,:,:]))
            #ftsw = max(0, ftsw_xy[i])
            col = 16 + int(ceil((1-ftsw)/0.1))
            nproduce ;(col)@M(-53,0,z-dz_sol)@g(Box(1,30,dz_sol))
            #nproduce ;(col)@M(-50,float(idcol)*30./float(nbcol),z-dz_sol)@g(Box(1,30./float(nbcol),dz_sol))




#aer:
#    global res_abs_i, dxyz, Hmaxcouv, Lsol, largsol
#    if(getIterationNb()>2):
#        for ty in range(5,20):
#          for tx in range(5,20):
#            for i in range(50):
#              z = 50*dxyz[2]-(i*dxyz[2])
#              x = tx*(dxyz[0])
#              y= ty*(dxyz[1])
#              xx0=-(dxyz[0]*Lsol/2)+dxyz[0]/2
#              yy0=-(dxyz[1]*largsol/2)+dxyz[1]/2
#              ftsw = max(0., res_abs_i[0][i][tx][ty])
#              col = 18 - int(ceil((ftsw)/0.025))
#              nproduce ;(col)@M(yy0+y,xx0+x,z+dxyz[0])@g(Box(dxyz[1]/2,1,dxyz[2]))


pattern(0):
    if visu_solsurf == 1:
        produce ;(1)@M((pattern8[1][0]+pattern8[0][0])/2.,(pattern8[1][1]+pattern8[0][1])/2.,0)@g(Box((pattern8[1][0]-pattern8[0][0])/2.,(pattern8[1][1]-pattern8[0][1])/2.,0.1))


attente(n):
    if visu_sol == 1:
        produce ;(1)@M(-53,0,0)@g(Box(1,30,150)) #pour creer fenetre de taille correcte


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (221,221,221) , diffuse = 0.723982 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_4 = pgl.Material("Color_4" , ambient = (10,14,241) , diffuse = 0.746888 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_16 = pgl.Material("Color_16" , ambient = (0,0,234) , diffuse = 0.641026 , transparency = 0.5 , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_17 = pgl.Material("Color_17" , ambient = (63,63,239) , diffuse = 0.573906 , transparency = 0.4825 , )
	Color_17.name = "Color_17"
	context.turtle.setMaterial(17,Color_17)
	Color_18 = pgl.Material("Color_18" , ambient = (127,127,244) , diffuse = 0.506787 , transparency = 0.465 , )
	Color_18.name = "Color_18"
	context.turtle.setMaterial(18,Color_18)
	Color_19 = pgl.Material("Color_19" , ambient = (191,191,249) , diffuse = 0.439668 , transparency = 0.4475 , )
	Color_19.name = "Color_19"
	context.turtle.setMaterial(19,Color_19)
	Color_20 = pgl.Material("Color_20" , ambient = (255,255,255) , diffuse = 0.372549 , transparency = 0.43 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (248,212,212) , diffuse = 0.433345 , transparency = 0.416667 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (242,170,170) , diffuse = 0.494142 , transparency = 0.403333 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	Color_23 = pgl.Material("Color_23" , ambient = (236,127,127) , diffuse = 0.554938 , transparency = 0.39 , )
	Color_23.name = "Color_23"
	context.turtle.setMaterial(23,Color_23)
	Color_24 = pgl.Material("Color_24" , ambient = (229,85,85) , diffuse = 0.615734 , transparency = 0.376667 , )
	Color_24.name = "Color_24"
	context.turtle.setMaterial(24,Color_24)
	Color_25 = pgl.Material("Color_25" , ambient = (223,42,42) , diffuse = 0.676531 , transparency = 0.363333 , )
	Color_25.name = "Color_25"
	context.turtle.setMaterial(25,Color_25)
	Color_26 = pgl.Material("Color_26" , ambient = (217,0,0) , diffuse = 0.737327 , transparency = 0.35 , )
	Color_26.name = "Color_26"
	context.turtle.setMaterial(26,Color_26)
	Color_30 = pgl.Material("Color_30" , ambient = (12,16,234) , diffuse = 0.683761 , )
	Color_30.name = "Color_30"
	context.turtle.setMaterial(30,Color_30)
	Color_31 = pgl.Material("Color_31" , ambient = (37,11,232) , diffuse = 0.689337 , )
	Color_31.name = "Color_31"
	context.turtle.setMaterial(31,Color_31)
	Color_32 = pgl.Material("Color_32" , ambient = (65,11,230) , diffuse = 0.694913 , )
	Color_32.name = "Color_32"
	context.turtle.setMaterial(32,Color_32)
	Color_33 = pgl.Material("Color_33" , ambient = (94,10,228) , diffuse = 0.700489 , )
	Color_33.name = "Color_33"
	context.turtle.setMaterial(33,Color_33)
	Color_34 = pgl.Material("Color_34" , ambient = (122,10,226) , diffuse = 0.706065 , )
	Color_34.name = "Color_34"
	context.turtle.setMaterial(34,Color_34)
	Color_35 = pgl.Material("Color_35" , ambient = (149,10,225) , diffuse = 0.711641 , )
	Color_35.name = "Color_35"
	context.turtle.setMaterial(35,Color_35)
	Color_36 = pgl.Material("Color_36" , ambient = (176,9,223) , diffuse = 0.717217 , )
	Color_36.name = "Color_36"
	context.turtle.setMaterial(36,Color_36)
	Color_37 = pgl.Material("Color_37" , ambient = (203,9,221) , diffuse = 0.722793 , )
	Color_37.name = "Color_37"
	context.turtle.setMaterial(37,Color_37)
